{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"equation-tree","text":"<p>Explain what your contribution is doing here</p> <p>You can include inline mathematics by wrapping LaTeX formatted math in <code>$</code> symbols: <code>$(3 &lt; 4)$</code> will render as:  \\((3 &lt; 4)\\)</p> <p>To include block mathematics wrap the expression with double <code>$$</code>:</p> <pre><code>$$\nE(\\mathbf{v}, \\mathbf{h}) = -\\sum_{i,j}w_{ij}v_i h_j - \\sum_i b_i v_i - \\sum_j c_j h_j\n$$\n</code></pre> <p>Will render as:</p> \\[ E(\\mathbf{v}, \\mathbf{h}) = -\\sum_{i,j}w_{ij}v_i h_j - \\sum_i b_i v_i - \\sum_j c_j h_j \\] <p>See more information on writing mathematical expressions here. </p>"},{"location":"Additional%20Example/","title":"Additional Example","text":"In\u00a0[\u00a0]: Copied! <pre>from autora.equation_tree.equation_tree import Example\n</pre> from autora.equation_tree.equation_tree import Example <p>Include inline mathematics like this: $4 &lt; 5$</p> <p>Include block mathematics like this (don't forget the empty lines above and below the block):</p> <p>$$   y + 1 = 4  $$</p> <p>... or this:</p> <p>\\begin{align}     p(v_i=1|\\mathbf{h}) &amp; = \\sigma\\left(\\sum_j w_{ij}h_j + b_i\\right) \\\\     p(h_j=1|\\mathbf{v}) &amp; = \\sigma\\left(\\sum_i w_{ij}v_i + c_j\\right) \\end{align}</p>"},{"location":"Additional%20Example/#additional-example","title":"Additional Example\u00b6","text":""},{"location":"Basic%20Usage/","title":"Basic Usage","text":"In\u00a0[1]: Copied! <pre>!pip install equation_tree\n</pre> !pip install equation_tree <pre>Requirement already satisfied: equation_tree in /Users/younesstrittmatter/Documents/GitHub/AutoRA/equation-tree/src (0.0.11.dev21+gc4ad4e6.d20230918)\r\nRequirement already satisfied: numpy in /Users/younesstrittmatter/Documents/GitHub/AutoRA/equation-tree/venv/lib/python3.11/site-packages (from equation_tree) (1.25.2)\r\nRequirement already satisfied: sympy in /Users/younesstrittmatter/Documents/GitHub/AutoRA/equation-tree/venv/lib/python3.11/site-packages (from equation_tree) (1.12)\r\nRequirement already satisfied: importlib_resources in /Users/younesstrittmatter/Documents/GitHub/AutoRA/equation-tree/venv/lib/python3.11/site-packages (from equation_tree) (6.0.1)\r\nRequirement already satisfied: tqdm in /Users/younesstrittmatter/Documents/GitHub/AutoRA/equation-tree/venv/lib/python3.11/site-packages (from equation_tree) (4.66.1)\r\nRequirement already satisfied: mpmath&gt;=0.19 in /Users/younesstrittmatter/Documents/GitHub/AutoRA/equation-tree/venv/lib/python3.11/site-packages (from sympy-&gt;equation_tree) (1.3.0)\r\n\r\n[notice] A new release of pip is available: 23.1.2 -&gt; 23.3.1\r\n[notice] To update, run: pip install --upgrade pip\r\n</pre> <p>Include inline mathematics like this: $4 &lt; 5$</p> <p>Include block mathematics like this (don't forget the empty lines above and below the block):</p> <p>$$   y + 1 = 4  $$</p> <p>... or this:</p> <p>\\begin{align}     p(v_i=1|\\mathbf{h}) &amp; = \\sigma\\left(\\sum_j w_{ij}h_j + b_i\\right) \\\\     p(h_j=1|\\mathbf{v}) &amp; = \\sigma\\left(\\sum_i w_{ij}v_i + c_j\\right) \\end{align}</p>"},{"location":"Basic%20Usage/#basic-usage","title":"Basic Usage\u00b6","text":""},{"location":"quickstart/","title":"Quickstart Guide","text":"<p>You will need:</p> <ul> <li><code>python</code> 3.8 or greater: https://www.python.org/downloads/</li> </ul> <pre><code>pip install -U equation-tree\n\"]\n</code></pre> <p>Check your installation by running: <pre><code>python -c \"from autora.equation_tree.equation_tree import Example\"\n</code></pre></p>"},{"location":"reference/SUMMARY/","title":"Code Reference","text":"<ul> <li>src<ul> <li>equation_tree<ul> <li>analysis</li> <li>defaults</li> <li>prior</li> <li>sample</li> <li>src<ul> <li>sample_tree_structure</li> <li>tree_node</li> </ul> </li> <li>tree</li> <li>util<ul> <li>conversions</li> <li>io</li> <li>priors</li> <li>type_check</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/src/equation_tree/","title":"Equation tree","text":""},{"location":"reference/src/equation_tree/analysis/","title":"Analysis","text":""},{"location":"reference/src/equation_tree/analysis/#src.equation_tree.analysis.get_counts","title":"<code>get_counts(trees)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; p = {\n...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n...     'features': {'constants': .5, 'variables': .5},\n...     'functions': {'sin': .5, 'cos': .5},\n...     'operators': {'+': .5, '-': .5},\n...     'function_conditionals': {\n...                             'sin': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'sin': .5, 'cos': .5},\n...                                 'operators': {'+': .5, '-': .5}\n...                             },\n...                             'cos': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'cos': .5, 'sin': .5},\n...                                 'operators': {'+': .5, '-': .5}\n...                             }\n...                         },\n...     'operator_conditionals': {\n...                             '+': {\n...                                 'features': {'constants': .5, 'variables': .5},\n...                                 'functions': {'sin': .5, 'cos': .5},\n...                                 'operators': {'+': .5, '-': .5}\n...                             },\n...                             '-': {\n...                                 'features': {'constants': .5, 'variables': .5},\n...                                 'functions': {'cos': .5, 'sin': .5},\n...                                 'operators': {'+': .5, '-': .5}\n...                             }\n...                         },\n... }\n&gt;&gt;&gt; pprint.pprint(p)\n{'features': {'constants': 0.5, 'variables': 0.5},\n 'function_conditionals': {'cos': {'features': {'constants': 0.0,\n                                                'variables': 1.0},\n                                   'functions': {'cos': 0.5, 'sin': 0.5},\n                                   'operators': {'+': 0.5, '-': 0.5}},\n                           'sin': {'features': {'constants': 0.0,\n                                                'variables': 1.0},\n                                   'functions': {'cos': 0.5, 'sin': 0.5},\n                                   'operators': {'+': 0.5, '-': 0.5}}},\n 'functions': {'cos': 0.5, 'sin': 0.5},\n 'operator_conditionals': {'+': {'features': {'constants': 0.5,\n                                              'variables': 0.5},\n                                 'functions': {'cos': 0.5, 'sin': 0.5},\n                                 'operators': {'+': 0.5, '-': 0.5}},\n                           '-': {'features': {'constants': 0.5,\n                                              'variables': 0.5},\n                                 'functions': {'cos': 0.5, 'sin': 0.5},\n                                 'operators': {'+': 0.5, '-': 0.5}}},\n 'operators': {'+': 0.5, '-': 0.5},\n 'structures': {'[0, 1, 1]': 0.3,\n                '[0, 1, 2, 3, 2, 3, 1]': 0.4,\n                '[0, 1, 2]': 0.3}}\n</code></pre> <pre><code>&gt;&gt;&gt; tree_list = [EquationTree.from_prior(p, 4) for _ in range(100)]\n&gt;&gt;&gt; len(tree_list)\n100\n&gt;&gt;&gt; example_tree = tree_list[2]\n&gt;&gt;&gt; example_tree.expr\n['+', '-', 'sin', 'x_1', 'cos', 'x_2', 'c_1']\n&gt;&gt;&gt; example_tree.sympy_expr\nc_1 + sin(x_1) - cos(x_2)\n&gt;&gt;&gt; pprint.pprint(example_tree.info)\n{'depth': 3,\n 'features': {'constants': 1, 'variables': 2},\n 'function_conditionals': {'cos': {'features': {'constants': 0, 'variables': 1},\n                                   'functions': {},\n                                   'operators': {}},\n                           'sin': {'features': {'constants': 0, 'variables': 1},\n                                   'functions': {},\n                                   'operators': {}}},\n 'functions': {'cos': 1, 'sin': 1},\n 'max_depth': 7,\n 'operator_conditionals': {'+': {'features': {'constants': 1, 'variables': 0},\n                                 'functions': {},\n                                 'operators': {'-': 1}},\n                           '-': {'features': {'constants': 0, 'variables': 0},\n                                 'functions': {'cos': 1, 'sin': 1},\n                                 'operators': {}}},\n 'operators': {'+': 1, '-': 1},\n 'structures': [0, 1, 2, 3, 2, 3, 1]}\n</code></pre> <pre><code>&gt;&gt;&gt; counts = get_counts(tree_list)\n&gt;&gt;&gt; pprint.pprint(counts)\n{'depth': {1: 32, 2: 27, 3: 41},\n 'features': {'constants': 44, 'variables': 170},\n 'function_conditionals': {'cos': {'features': {'constants': 0,\n                                                'variables': 54},\n                                   'functions': {'cos': 7, 'sin': 6},\n                                   'operators': {}},\n                           'sin': {'features': {'constants': 0,\n                                                'variables': 55},\n                                   'functions': {'cos': 7, 'sin': 7},\n                                   'operators': {}}},\n 'functions': {'cos': 67, 'sin': 69},\n 'max_depth': {3: 59, 7: 41},\n 'operator_conditionals': {'+': {'features': {'constants': 24, 'variables': 29},\n                                 'functions': {'cos': 27, 'sin': 21},\n                                 'operators': {'+': 14, '-': 9}},\n                           '-': {'features': {'constants': 20, 'variables': 32},\n                                 'functions': {'cos': 13, 'sin': 21},\n                                 'operators': {'+': 10, '-': 8}}},\n 'operators': {'+': 62, '-': 52},\n 'structures': {'[0, 1, 1]': 32, '[0, 1, 2, 3, 2, 3, 1]': 41, '[0, 1, 2]': 27}}\n</code></pre> Source code in <code>src/equation_tree/analysis.py</code> <pre><code>def get_counts(trees: List[EquationTree]):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import pprint\n        &gt;&gt;&gt; np.random.seed(42)\n        &gt;&gt;&gt; p = {\n        ...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n        ...     'features': {'constants': .5, 'variables': .5},\n        ...     'functions': {'sin': .5, 'cos': .5},\n        ...     'operators': {'+': .5, '-': .5},\n        ...     'function_conditionals': {\n        ...                             'sin': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'sin': .5, 'cos': .5},\n        ...                                 'operators': {'+': .5, '-': .5}\n        ...                             },\n        ...                             'cos': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'cos': .5, 'sin': .5},\n        ...                                 'operators': {'+': .5, '-': .5}\n        ...                             }\n        ...                         },\n        ...     'operator_conditionals': {\n        ...                             '+': {\n        ...                                 'features': {'constants': .5, 'variables': .5},\n        ...                                 'functions': {'sin': .5, 'cos': .5},\n        ...                                 'operators': {'+': .5, '-': .5}\n        ...                             },\n        ...                             '-': {\n        ...                                 'features': {'constants': .5, 'variables': .5},\n        ...                                 'functions': {'cos': .5, 'sin': .5},\n        ...                                 'operators': {'+': .5, '-': .5}\n        ...                             }\n        ...                         },\n        ... }\n        &gt;&gt;&gt; pprint.pprint(p)\n        {'features': {'constants': 0.5, 'variables': 0.5},\n         'function_conditionals': {'cos': {'features': {'constants': 0.0,\n                                                        'variables': 1.0},\n                                           'functions': {'cos': 0.5, 'sin': 0.5},\n                                           'operators': {'+': 0.5, '-': 0.5}},\n                                   'sin': {'features': {'constants': 0.0,\n                                                        'variables': 1.0},\n                                           'functions': {'cos': 0.5, 'sin': 0.5},\n                                           'operators': {'+': 0.5, '-': 0.5}}},\n         'functions': {'cos': 0.5, 'sin': 0.5},\n         'operator_conditionals': {'+': {'features': {'constants': 0.5,\n                                                      'variables': 0.5},\n                                         'functions': {'cos': 0.5, 'sin': 0.5},\n                                         'operators': {'+': 0.5, '-': 0.5}},\n                                   '-': {'features': {'constants': 0.5,\n                                                      'variables': 0.5},\n                                         'functions': {'cos': 0.5, 'sin': 0.5},\n                                         'operators': {'+': 0.5, '-': 0.5}}},\n         'operators': {'+': 0.5, '-': 0.5},\n         'structures': {'[0, 1, 1]': 0.3,\n                        '[0, 1, 2, 3, 2, 3, 1]': 0.4,\n                        '[0, 1, 2]': 0.3}}\n\n\n        &gt;&gt;&gt; tree_list = [EquationTree.from_prior(p, 4) for _ in range(100)]\n        &gt;&gt;&gt; len(tree_list)\n        100\n        &gt;&gt;&gt; example_tree = tree_list[2]\n        &gt;&gt;&gt; example_tree.expr\n        ['+', '-', 'sin', 'x_1', 'cos', 'x_2', 'c_1']\n        &gt;&gt;&gt; example_tree.sympy_expr\n        c_1 + sin(x_1) - cos(x_2)\n        &gt;&gt;&gt; pprint.pprint(example_tree.info)\n        {'depth': 3,\n         'features': {'constants': 1, 'variables': 2},\n         'function_conditionals': {'cos': {'features': {'constants': 0, 'variables': 1},\n                                           'functions': {},\n                                           'operators': {}},\n                                   'sin': {'features': {'constants': 0, 'variables': 1},\n                                           'functions': {},\n                                           'operators': {}}},\n         'functions': {'cos': 1, 'sin': 1},\n         'max_depth': 7,\n         'operator_conditionals': {'+': {'features': {'constants': 1, 'variables': 0},\n                                         'functions': {},\n                                         'operators': {'-': 1}},\n                                   '-': {'features': {'constants': 0, 'variables': 0},\n                                         'functions': {'cos': 1, 'sin': 1},\n                                         'operators': {}}},\n         'operators': {'+': 1, '-': 1},\n         'structures': [0, 1, 2, 3, 2, 3, 1]}\n\n        &gt;&gt;&gt; counts = get_counts(tree_list)\n        &gt;&gt;&gt; pprint.pprint(counts)\n        {'depth': {1: 32, 2: 27, 3: 41},\n         'features': {'constants': 44, 'variables': 170},\n         'function_conditionals': {'cos': {'features': {'constants': 0,\n                                                        'variables': 54},\n                                           'functions': {'cos': 7, 'sin': 6},\n                                           'operators': {}},\n                                   'sin': {'features': {'constants': 0,\n                                                        'variables': 55},\n                                           'functions': {'cos': 7, 'sin': 7},\n                                           'operators': {}}},\n         'functions': {'cos': 67, 'sin': 69},\n         'max_depth': {3: 59, 7: 41},\n         'operator_conditionals': {'+': {'features': {'constants': 24, 'variables': 29},\n                                         'functions': {'cos': 27, 'sin': 21},\n                                         'operators': {'+': 14, '-': 9}},\n                                   '-': {'features': {'constants': 20, 'variables': 32},\n                                         'functions': {'cos': 13, 'sin': 21},\n                                         'operators': {'+': 10, '-': 8}}},\n         'operators': {'+': 62, '-': 52},\n         'structures': {'[0, 1, 1]': 32, '[0, 1, 2, 3, 2, 3, 1]': 41, '[0, 1, 2]': 27}}\n    \"\"\"\n    info: Dict = {}\n    max_depth: Dict = {}\n    depth: Dict = {}\n    structures: Dict = {}\n    features: Dict = {}\n    functions: Dict = {}\n    operators: Dict = {}\n    function_conditionals: Dict = {}\n    operator_conditionals: Dict = {}\n    for t in trees:\n        _info = t.info\n        if \"max_depth\" in _info.keys():\n            _update(max_depth, _info[\"max_depth\"])\n        if \"depth\" in _info.keys():\n            _update(depth, _info[\"depth\"])\n        if \"structures\" in _info.keys():\n            _update(structures, str(_info[\"structures\"]))\n        if \"features\" in _info.keys():\n            for key, val in _info[\"features\"].items():\n                _update(features, key, val)\n        if \"functions\" in _info.keys():\n            for key, val in _info[\"functions\"].items():\n                _update(functions, key, val)\n        if \"operators\" in _info.keys():\n            for key, val in _info[\"operators\"].items():\n                _update(operators, key, val)\n        if \"function_conditionals\" in _info.keys():\n            fnc_con_dict = _info[\"function_conditionals\"]\n            for k, fnc_dict in fnc_con_dict.items():\n                if k not in function_conditionals.keys():\n                    function_conditionals[k] = {\n                        \"features\": {},\n                        \"functions\": {},\n                        \"operators\": {},\n                    }\n                fnc_dct_features = fnc_dict[\"features\"]\n                fnc_fct_functions = fnc_dict[\"functions\"]\n                fnc_fct_operators = fnc_dict[\"operators\"]\n                for key, val in fnc_dct_features.items():\n                    _update(function_conditionals[k][\"features\"], key, val)\n                for key, val in fnc_fct_functions.items():\n                    _update(function_conditionals[k][\"functions\"], key, val)\n                for key, val in fnc_fct_operators.items():\n                    _update(function_conditionals[k][\"operators\"], key, val)\n        if \"operator_conditionals\" in _info.keys():\n            op_con_dict = _info[\"operator_conditionals\"]\n            for k, op_dict in op_con_dict.items():\n                if k not in operator_conditionals.keys():\n                    operator_conditionals[k] = {\n                        \"features\": {},\n                        \"functions\": {},\n                        \"operators\": {},\n                    }\n                op_dct_features = op_dict[\"features\"]\n                op_fct_functions = op_dict[\"functions\"]\n                op_fct_operators = op_dict[\"operators\"]\n                for key, val in op_dct_features.items():\n                    _update(operator_conditionals[k][\"features\"], key, val)\n                for key, val in op_fct_functions.items():\n                    _update(operator_conditionals[k][\"functions\"], key, val)\n                for key, val in op_fct_operators.items():\n                    _update(operator_conditionals[k][\"operators\"], key, val)\n\n    info[\"max_depth\"] = max_depth\n    info[\"depth\"] = depth\n    info[\"structures\"] = structures\n    info[\"features\"] = features\n    info[\"functions\"] = functions\n    info[\"operators\"] = operators\n    info[\"function_conditionals\"] = function_conditionals\n    info[\"operator_conditionals\"] = operator_conditionals\n    return info\n</code></pre>"},{"location":"reference/src/equation_tree/analysis/#src.equation_tree.analysis.get_frequencies","title":"<code>get_frequencies(trees)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; p = {\n...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n...     'features': {'constants': .5, 'variables': .5},\n...     'functions': {'sin': .5, 'cos': .5},\n...     'operators': {'+': .5, '-': .5},\n...     'function_conditionals': {\n...                             'sin': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'sin': .5, 'cos': .5},\n...                                 'operators': {'+': .5, '-': .5}\n...                             },\n...                             'cos': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'cos': .5, 'sin': .5},\n...                                 'operators': {'+': .5, '-': .5}\n...                             }\n...                         },\n...     'operator_conditionals': {\n...                             '+': {\n...                                 'features': {'constants': .5, 'variables': .5},\n...                                 'functions': {'sin': .5, 'cos': .5},\n...                                 'operators': {'+': .5, '-': .5}\n...                             },\n...                             '-': {\n...                                 'features': {'constants': .5, 'variables': .5},\n...                                 'functions': {'cos': .5, 'sin': .5},\n...                                 'operators': {'+': .5, '-': .5}\n...                             }\n...                         },\n... }\n&gt;&gt;&gt; pprint.pprint(p)\n{'features': {'constants': 0.5, 'variables': 0.5},\n 'function_conditionals': {'cos': {'features': {'constants': 0.0,\n                                                'variables': 1.0},\n                                   'functions': {'cos': 0.5, 'sin': 0.5},\n                                   'operators': {'+': 0.5, '-': 0.5}},\n                           'sin': {'features': {'constants': 0.0,\n                                                'variables': 1.0},\n                                   'functions': {'cos': 0.5, 'sin': 0.5},\n                                   'operators': {'+': 0.5, '-': 0.5}}},\n 'functions': {'cos': 0.5, 'sin': 0.5},\n 'operator_conditionals': {'+': {'features': {'constants': 0.5,\n                                              'variables': 0.5},\n                                 'functions': {'cos': 0.5, 'sin': 0.5},\n                                 'operators': {'+': 0.5, '-': 0.5}},\n                           '-': {'features': {'constants': 0.5,\n                                              'variables': 0.5},\n                                 'functions': {'cos': 0.5, 'sin': 0.5},\n                                 'operators': {'+': 0.5, '-': 0.5}}},\n 'operators': {'+': 0.5, '-': 0.5},\n 'structures': {'[0, 1, 1]': 0.3,\n                '[0, 1, 2, 3, 2, 3, 1]': 0.4,\n                '[0, 1, 2]': 0.3}}\n</code></pre> <pre><code>&gt;&gt;&gt; tree_list = [EquationTree.from_prior(p, 4) for _ in range(100)]\n&gt;&gt;&gt; len(tree_list)\n100\n&gt;&gt;&gt; example_tree = tree_list[2]\n&gt;&gt;&gt; example_tree.expr\n['+', '-', 'sin', 'x_1', 'cos', 'x_2', 'c_1']\n&gt;&gt;&gt; example_tree.sympy_expr\nc_1 + sin(x_1) - cos(x_2)\n&gt;&gt;&gt; pprint.pprint(example_tree.info)\n{'depth': 3,\n 'features': {'constants': 1, 'variables': 2},\n 'function_conditionals': {'cos': {'features': {'constants': 0, 'variables': 1},\n                                   'functions': {},\n                                   'operators': {}},\n                           'sin': {'features': {'constants': 0, 'variables': 1},\n                                   'functions': {},\n                                   'operators': {}}},\n 'functions': {'cos': 1, 'sin': 1},\n 'max_depth': 7,\n 'operator_conditionals': {'+': {'features': {'constants': 1, 'variables': 0},\n                                 'functions': {},\n                                 'operators': {'-': 1}},\n                           '-': {'features': {'constants': 0, 'variables': 0},\n                                 'functions': {'cos': 1, 'sin': 1},\n                                 'operators': {}}},\n 'operators': {'+': 1, '-': 1},\n 'structures': [0, 1, 2, 3, 2, 3, 1]}\n</code></pre> <pre><code>&gt;&gt;&gt; frequencies = get_frequencies(tree_list)\n&gt;&gt;&gt; pprint.pprint(frequencies)\n{'depth': {1: 0.32, 2: 0.27, 3: 0.41},\n 'features': {'constants': 0.205607476635514, 'variables': 0.794392523364486},\n 'function_conditionals': {'cos': {'features': {'constants': 0.0,\n                                                'variables': 1.0},\n                                   'functions': {'cos': 0.5384615384615384,\n                                                 'sin': 0.46153846153846156},\n                                   'operators': {}},\n                           'sin': {'features': {'constants': 0.0,\n                                                'variables': 1.0},\n                                   'functions': {'cos': 0.5, 'sin': 0.5},\n                                   'operators': {}}},\n 'functions': {'cos': 0.49264705882352944, 'sin': 0.5073529411764706},\n 'max_depth': {3: 0.59, 7: 0.41},\n 'operator_conditionals': {'+': {'features': {'constants': 0.4528301886792453,\n                                              'variables': 0.5471698113207547},\n                                 'functions': {'cos': 0.5625, 'sin': 0.4375},\n                                 'operators': {'+': 0.6086956521739131,\n                                               '-': 0.391304347826087}},\n                           '-': {'features': {'constants': 0.38461538461538464,\n                                              'variables': 0.6153846153846154},\n                                 'functions': {'cos': 0.38235294117647056,\n                                               'sin': 0.6176470588235294},\n                                 'operators': {'+': 0.5555555555555556,\n                                               '-': 0.4444444444444444}}},\n 'operators': {'+': 0.543859649122807, '-': 0.45614035087719296},\n 'structures': {'[0, 1, 1]': 0.32,\n                '[0, 1, 2, 3, 2, 3, 1]': 0.41,\n                '[0, 1, 2]': 0.27}}\n</code></pre> Source code in <code>src/equation_tree/analysis.py</code> <pre><code>def get_frequencies(trees: List[EquationTree]):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import pprint\n        &gt;&gt;&gt; np.random.seed(42)\n        &gt;&gt;&gt; p = {\n        ...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n        ...     'features': {'constants': .5, 'variables': .5},\n        ...     'functions': {'sin': .5, 'cos': .5},\n        ...     'operators': {'+': .5, '-': .5},\n        ...     'function_conditionals': {\n        ...                             'sin': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'sin': .5, 'cos': .5},\n        ...                                 'operators': {'+': .5, '-': .5}\n        ...                             },\n        ...                             'cos': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'cos': .5, 'sin': .5},\n        ...                                 'operators': {'+': .5, '-': .5}\n        ...                             }\n        ...                         },\n        ...     'operator_conditionals': {\n        ...                             '+': {\n        ...                                 'features': {'constants': .5, 'variables': .5},\n        ...                                 'functions': {'sin': .5, 'cos': .5},\n        ...                                 'operators': {'+': .5, '-': .5}\n        ...                             },\n        ...                             '-': {\n        ...                                 'features': {'constants': .5, 'variables': .5},\n        ...                                 'functions': {'cos': .5, 'sin': .5},\n        ...                                 'operators': {'+': .5, '-': .5}\n        ...                             }\n        ...                         },\n        ... }\n        &gt;&gt;&gt; pprint.pprint(p)\n        {'features': {'constants': 0.5, 'variables': 0.5},\n         'function_conditionals': {'cos': {'features': {'constants': 0.0,\n                                                        'variables': 1.0},\n                                           'functions': {'cos': 0.5, 'sin': 0.5},\n                                           'operators': {'+': 0.5, '-': 0.5}},\n                                   'sin': {'features': {'constants': 0.0,\n                                                        'variables': 1.0},\n                                           'functions': {'cos': 0.5, 'sin': 0.5},\n                                           'operators': {'+': 0.5, '-': 0.5}}},\n         'functions': {'cos': 0.5, 'sin': 0.5},\n         'operator_conditionals': {'+': {'features': {'constants': 0.5,\n                                                      'variables': 0.5},\n                                         'functions': {'cos': 0.5, 'sin': 0.5},\n                                         'operators': {'+': 0.5, '-': 0.5}},\n                                   '-': {'features': {'constants': 0.5,\n                                                      'variables': 0.5},\n                                         'functions': {'cos': 0.5, 'sin': 0.5},\n                                         'operators': {'+': 0.5, '-': 0.5}}},\n         'operators': {'+': 0.5, '-': 0.5},\n         'structures': {'[0, 1, 1]': 0.3,\n                        '[0, 1, 2, 3, 2, 3, 1]': 0.4,\n                        '[0, 1, 2]': 0.3}}\n\n\n        &gt;&gt;&gt; tree_list = [EquationTree.from_prior(p, 4) for _ in range(100)]\n        &gt;&gt;&gt; len(tree_list)\n        100\n        &gt;&gt;&gt; example_tree = tree_list[2]\n        &gt;&gt;&gt; example_tree.expr\n        ['+', '-', 'sin', 'x_1', 'cos', 'x_2', 'c_1']\n        &gt;&gt;&gt; example_tree.sympy_expr\n        c_1 + sin(x_1) - cos(x_2)\n        &gt;&gt;&gt; pprint.pprint(example_tree.info)\n        {'depth': 3,\n         'features': {'constants': 1, 'variables': 2},\n         'function_conditionals': {'cos': {'features': {'constants': 0, 'variables': 1},\n                                           'functions': {},\n                                           'operators': {}},\n                                   'sin': {'features': {'constants': 0, 'variables': 1},\n                                           'functions': {},\n                                           'operators': {}}},\n         'functions': {'cos': 1, 'sin': 1},\n         'max_depth': 7,\n         'operator_conditionals': {'+': {'features': {'constants': 1, 'variables': 0},\n                                         'functions': {},\n                                         'operators': {'-': 1}},\n                                   '-': {'features': {'constants': 0, 'variables': 0},\n                                         'functions': {'cos': 1, 'sin': 1},\n                                         'operators': {}}},\n         'operators': {'+': 1, '-': 1},\n         'structures': [0, 1, 2, 3, 2, 3, 1]}\n\n        &gt;&gt;&gt; frequencies = get_frequencies(tree_list)\n        &gt;&gt;&gt; pprint.pprint(frequencies)\n        {'depth': {1: 0.32, 2: 0.27, 3: 0.41},\n         'features': {'constants': 0.205607476635514, 'variables': 0.794392523364486},\n         'function_conditionals': {'cos': {'features': {'constants': 0.0,\n                                                        'variables': 1.0},\n                                           'functions': {'cos': 0.5384615384615384,\n                                                         'sin': 0.46153846153846156},\n                                           'operators': {}},\n                                   'sin': {'features': {'constants': 0.0,\n                                                        'variables': 1.0},\n                                           'functions': {'cos': 0.5, 'sin': 0.5},\n                                           'operators': {}}},\n         'functions': {'cos': 0.49264705882352944, 'sin': 0.5073529411764706},\n         'max_depth': {3: 0.59, 7: 0.41},\n         'operator_conditionals': {'+': {'features': {'constants': 0.4528301886792453,\n                                                      'variables': 0.5471698113207547},\n                                         'functions': {'cos': 0.5625, 'sin': 0.4375},\n                                         'operators': {'+': 0.6086956521739131,\n                                                       '-': 0.391304347826087}},\n                                   '-': {'features': {'constants': 0.38461538461538464,\n                                                      'variables': 0.6153846153846154},\n                                         'functions': {'cos': 0.38235294117647056,\n                                                       'sin': 0.6176470588235294},\n                                         'operators': {'+': 0.5555555555555556,\n                                                       '-': 0.4444444444444444}}},\n         'operators': {'+': 0.543859649122807, '-': 0.45614035087719296},\n         'structures': {'[0, 1, 1]': 0.32,\n                        '[0, 1, 2, 3, 2, 3, 1]': 0.41,\n                        '[0, 1, 2]': 0.27}}\n    \"\"\"\n    info: Dict = {}\n    max_depth: Dict = {}\n    depth: Dict = {}\n    structures: Dict = {}\n    features: Dict = {}\n    functions: Dict = {}\n    operators: Dict = {}\n    function_conditionals: Dict = {}\n    operator_conditionals: Dict = {}\n    for t in trees:\n        _info = t.info\n        if \"max_depth\" in _info.keys():\n            _update(max_depth, _info[\"max_depth\"])\n        if \"depth\" in _info.keys():\n            _update(depth, _info[\"depth\"])\n        if \"structures\" in _info.keys():\n            _update(structures, str(_info[\"structures\"]))\n        if \"features\" in _info.keys():\n            for key, val in _info[\"features\"].items():\n                _update(features, key, val)\n        if \"functions\" in _info.keys():\n            for key, val in _info[\"functions\"].items():\n                _update(functions, key, val)\n        if \"operators\" in _info.keys():\n            for key, val in _info[\"operators\"].items():\n                _update(operators, key, val)\n        if \"function_conditionals\" in _info.keys():\n            fnc_con_dict = _info[\"function_conditionals\"]\n            for k, fnc_dict in fnc_con_dict.items():\n                if k not in function_conditionals.keys():\n                    function_conditionals[k] = {\n                        \"features\": {},\n                        \"functions\": {},\n                        \"operators\": {},\n                    }\n                fnc_dct_features = fnc_dict[\"features\"]\n                fnc_fct_functions = fnc_dict[\"functions\"]\n                fnc_fct_operators = fnc_dict[\"operators\"]\n                for key, val in fnc_dct_features.items():\n                    _update(function_conditionals[k][\"features\"], key, val)\n                for key, val in fnc_fct_functions.items():\n                    _update(function_conditionals[k][\"functions\"], key, val)\n                for key, val in fnc_fct_operators.items():\n                    _update(function_conditionals[k][\"operators\"], key, val)\n        if \"operator_conditionals\" in _info.keys():\n            op_con_dict = _info[\"operator_conditionals\"]\n            for k, op_dict in op_con_dict.items():\n                if k not in operator_conditionals.keys():\n                    operator_conditionals[k] = {\n                        \"features\": {},\n                        \"functions\": {},\n                        \"operators\": {},\n                    }\n                op_dct_features = op_dict[\"features\"]\n                op_fct_functions = op_dict[\"functions\"]\n                op_fct_operators = op_dict[\"operators\"]\n                for key, val in op_dct_features.items():\n                    _update(operator_conditionals[k][\"features\"], key, val)\n                for key, val in op_fct_functions.items():\n                    _update(operator_conditionals[k][\"functions\"], key, val)\n                for key, val in op_fct_operators.items():\n                    _update(operator_conditionals[k][\"operators\"], key, val)\n    for k_c in function_conditionals:\n        for k in [\"features\", \"functions\", \"operators\"]:\n            if k in function_conditionals[k_c]:\n                function_conditionals[k_c][k] = normalized_dict(\n                    function_conditionals[k_c][k]\n                )\n    for k_c in operator_conditionals:\n        for k in [\"features\", \"functions\", \"operators\"]:\n            if k in operator_conditionals[k_c]:\n                operator_conditionals[k_c][k] = normalized_dict(\n                    operator_conditionals[k_c][k]\n                )\n\n    info[\"max_depth\"] = normalized_dict(max_depth)\n    info[\"depth\"] = normalized_dict(depth)\n    info[\"structures\"] = normalized_dict(structures)\n    info[\"features\"] = normalized_dict(features)\n    info[\"functions\"] = normalized_dict(functions)\n    info[\"operators\"] = normalized_dict(operators)\n    info[\"function_conditionals\"] = function_conditionals\n    info[\"operator_conditionals\"] = operator_conditionals\n    return info\n</code></pre>"},{"location":"reference/src/equation_tree/defaults/","title":"Defaults","text":""},{"location":"reference/src/equation_tree/prior/","title":"Prior","text":""},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.add","title":"<code>add(prior_a, prior_b)</code>","text":"<p>import pprint a = {'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': .1, 'b_2': .3}} b = {'a': {'a_1': 2, 'a_2': 4}, 'c': {'b_1': 3, 'b_2': 3}} pprint.pprint(add(a, b)) {'a': {'a_1': 5, 'a_2': 6},  'b': {'b_1': 0.1, 'b_2': 0.3},  'c': {'b_1': 3, 'b_2': 3}}</p> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def add(prior_a, prior_b):\n    \"\"\"\n    &gt;&gt;&gt; import pprint\n    &gt;&gt;&gt; a = {'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': .1, 'b_2': .3}}\n    &gt;&gt;&gt; b = {'a': {'a_1': 2, 'a_2': 4}, 'c': {'b_1': 3, 'b_2': 3}}\n    &gt;&gt;&gt; pprint.pprint(add(a, b))\n    {'a': {'a_1': 5, 'a_2': 6},\n     'b': {'b_1': 0.1, 'b_2': 0.3},\n     'c': {'b_1': 3, 'b_2': 3}}\n\n    \"\"\"\n    tmp_a = copy.deepcopy(prior_a)\n    tmp_b = copy.deepcopy(prior_b)\n\n    def _rec_add(a, b):\n        for k, val in a.items():\n            if k in b.keys():\n                if isinstance(val, dict) and isinstance(b[k], dict):\n                    _rec_add(a[k], b[k])\n                elif not isinstance(val, dict) and not isinstance(b[k], dict):\n                    a[k] += b[k]\n\n    _rec_add(tmp_a, tmp_b)\n    return append(tmp_a, tmp_b)\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.filter_keys","title":"<code>filter_keys(dict_a, dict_b)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; a = {'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': .1, 'b_2': .3}, 'c': {}}\n&gt;&gt;&gt; b = {'a': {'a_1': 2, 'a_2': 4}, 'b': {'b_1': 3, 'c_1': 3}}\n&gt;&gt;&gt; pprint.pprint(filter_keys(a, b))\n{'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': 0.1}}\n</code></pre> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def filter_keys(dict_a, dict_b):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pprint\n        &gt;&gt;&gt; a = {'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': .1, 'b_2': .3}, 'c': {}}\n        &gt;&gt;&gt; b = {'a': {'a_1': 2, 'a_2': 4}, 'b': {'b_1': 3, 'c_1': 3}}\n        &gt;&gt;&gt; pprint.pprint(filter_keys(a, b))\n        {'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': 0.1}}\n    \"\"\"\n    tmp_a = copy.deepcopy(dict_a)\n    tmp_b = copy.deepcopy(dict_b)\n\n    def _rec_f_key(a, b):\n        for k in list(a.keys()):\n            if k in b.keys():\n                if isinstance(a[k], dict) and isinstance(b[k], dict):\n                    _rec_f_key(a[k], b[k])\n                else:\n                    a[k] = a[k]\n            else:\n                del a[k]\n\n    _rec_f_key(tmp_a, tmp_b)\n    return tmp_a\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.get_defined_functions","title":"<code>get_defined_functions(prior)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; test_prior = {\n...     'functions': {'sin': 2},\n...     'function_conditionals': {'sin': {'features': {'constants': 0, 'variables': 2},\n...                                   'functions': {},\n...                                       'operators': {}}},\n...     'operator_conditionals': {'+': {'features': {'constants': 0, 'variables': 1},\n...                                     'functions': {'cos': 2},\n...                                     'operators': {'-': 1}},\n...                               '-': {'features': {'constants': 0, 'variables': 0},\n...                                     'functions': {'sin': 2, 'abs': 1},\n...                                     'operators': {}}},\n...     'operators': {'+': 1, '-': 1},\n...     'structure': [0, 1, 2, 3, 2, 3, 1]}\n&gt;&gt;&gt; set(get_defined_functions(test_prior)) == set(['sin', 'abs', 'cos'])\nTrue\n</code></pre> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def get_defined_functions(prior):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; test_prior = {\n        ...     'functions': {'sin': 2},\n        ...     'function_conditionals': {'sin': {'features': {'constants': 0, 'variables': 2},\n        ...                                   'functions': {},\n        ...                                       'operators': {}}},\n        ...     'operator_conditionals': {'+': {'features': {'constants': 0, 'variables': 1},\n        ...                                     'functions': {'cos': 2},\n        ...                                     'operators': {'-': 1}},\n        ...                               '-': {'features': {'constants': 0, 'variables': 0},\n        ...                                     'functions': {'sin': 2, 'abs': 1},\n        ...                                     'operators': {}}},\n        ...     'operators': {'+': 1, '-': 1},\n        ...     'structure': [0, 1, 2, 3, 2, 3, 1]}\n        &gt;&gt;&gt; set(get_defined_functions(test_prior)) == set(['sin', 'abs', 'cos'])\n        True\n    \"\"\"\n    return _get_defined(prior, \"functions\", \"function_conditionals\")\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.get_defined_operators","title":"<code>get_defined_operators(prior)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; test_prior = {\n...     'function_conditionals': {'sin': {'features': {'constants': 0, 'variables': 2},\n...                                   'functions': {},\n...                                       'operators': {}}},\n...     'functions': {'sin': 2},\n...     'operator_conditionals': {'+': {'features': {'constants': 0, 'variables': 1},\n...                                     'functions': {'cos': 2},\n...                                     'operators': {'**': 1}},\n...                               '/': {'features': {'constants': 0, 'variables': 0},\n...                                     'functions': {'sin': 2},\n...                                     'operators': {}}},\n...     'operators': {'+': 1, '-': 1},\n...     'structure': [0, 1, 2, 3, 2, 3, 1]}\n&gt;&gt;&gt; set(get_defined_operators(test_prior)) == set(['+', '/', '**', '-'])\nTrue\n</code></pre> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def get_defined_operators(prior):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; test_prior = {\n        ...     'function_conditionals': {'sin': {'features': {'constants': 0, 'variables': 2},\n        ...                                   'functions': {},\n        ...                                       'operators': {}}},\n        ...     'functions': {'sin': 2},\n        ...     'operator_conditionals': {'+': {'features': {'constants': 0, 'variables': 1},\n        ...                                     'functions': {'cos': 2},\n        ...                                     'operators': {'**': 1}},\n        ...                               '/': {'features': {'constants': 0, 'variables': 0},\n        ...                                     'functions': {'sin': 2},\n        ...                                     'operators': {}}},\n        ...     'operators': {'+': 1, '-': 1},\n        ...     'structure': [0, 1, 2, 3, 2, 3, 1]}\n        &gt;&gt;&gt; set(get_defined_operators(test_prior)) == set(['+', '/', '**', '-'])\n        True\n    \"\"\"\n    return _get_defined(prior, \"operators\", \"operator_conditionals\")\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.multiply","title":"<code>multiply(a, b)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; prior_a = {'a':\n...                 {'a_1':  .2, 'a_2': .8},\n...             'b': {\n...                 'b_1' : {'b_1_1': .25, 'b_1_2': .5, 'b_1_3': .25}\n...             }\n...         }\n&gt;&gt;&gt; prior_b = {'a':\n...                 {'a_1':  4, 'a_2': 1},\n...             'b': {\n...                 'b_1' : {'b_1_1': 4 , 'b_1_2': 1, 'b_1_3': 4}\n...             },\n...             'c': {'c_1': .9, 'c_2': .1}\n...         }\n&gt;&gt;&gt; product = multiply(prior_a, prior_b)\n&gt;&gt;&gt; pprint.pprint(product)\n{'a': {'a_1': 0.8, 'a_2': 0.8},\n 'b': {'b_1': {'b_1_1': 1.0, 'b_1_2': 0.5, 'b_1_3': 1.0}},\n 'c': {'c_1': 0.9, 'c_2': 0.1}}\n&gt;&gt;&gt; normalize(product)\n&gt;&gt;&gt; pprint.pprint(product)\n{'a': {'a_1': 0.5, 'a_2': 0.5},\n 'b': {'b_1': {'b_1_1': 0.4, 'b_1_2': 0.2, 'b_1_3': 0.4}},\n 'c': {'c_1': 0.9, 'c_2': 0.1}}\n</code></pre> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def multiply(a, b):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pprint\n        &gt;&gt;&gt; prior_a = {'a':\n        ...                 {'a_1':  .2, 'a_2': .8},\n        ...             'b': {\n        ...                 'b_1' : {'b_1_1': .25, 'b_1_2': .5, 'b_1_3': .25}\n        ...             }\n        ...         }\n        &gt;&gt;&gt; prior_b = {'a':\n        ...                 {'a_1':  4, 'a_2': 1},\n        ...             'b': {\n        ...                 'b_1' : {'b_1_1': 4 , 'b_1_2': 1, 'b_1_3': 4}\n        ...             },\n        ...             'c': {'c_1': .9, 'c_2': .1}\n        ...         }\n        &gt;&gt;&gt; product = multiply(prior_a, prior_b)\n        &gt;&gt;&gt; pprint.pprint(product)\n        {'a': {'a_1': 0.8, 'a_2': 0.8},\n         'b': {'b_1': {'b_1_1': 1.0, 'b_1_2': 0.5, 'b_1_3': 1.0}},\n         'c': {'c_1': 0.9, 'c_2': 0.1}}\n        &gt;&gt;&gt; normalize(product)\n        &gt;&gt;&gt; pprint.pprint(product)\n        {'a': {'a_1': 0.5, 'a_2': 0.5},\n         'b': {'b_1': {'b_1_1': 0.4, 'b_1_2': 0.2, 'b_1_3': 0.4}},\n         'c': {'c_1': 0.9, 'c_2': 0.1}}\n    \"\"\"\n    tmp_a = copy.deepcopy(a)\n    tmp_b = copy.deepcopy(b)\n\n    def _multiply(_a, _b):\n        for k, val in _a.items():\n            if k in _b.keys():\n                if isinstance(val, dict) and isinstance(_b[k], dict):\n                    _multiply(val, _b[k])\n                elif not isinstance(val, dict) and not isinstance(_b[k], dict):\n                    res = val * _b[k]\n                    _a[k] = res\n\n    _multiply(tmp_a, tmp_b)\n    tmp_a = append(tmp_a, tmp_b)\n\n    return tmp_a\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.prior_from_space","title":"<code>prior_from_space(space)</code>","text":"<p>Uniform prior from a list of strings Examples:     &gt;&gt;&gt; import pprint     &gt;&gt;&gt; operator_space = ['+', '-', '', '/', '^']     &gt;&gt;&gt; operator_prior = prior_from_space(operator_space)     &gt;&gt;&gt; pprint.pprint(operator_prior)     {'': 0.2, '+': 0.2, '-': 0.2, '/': 0.2, '^': 0.2}</p> <pre><code>&gt;&gt;&gt; function_space = ['sin', 'cos', 'tan', 'exp', 'log', 'sqrt', 'abs']\n&gt;&gt;&gt; function_prior = prior_from_space(function_space)\n&gt;&gt;&gt; pprint.pprint(function_prior)\n{'abs': 0.14285714285714285,\n 'cos': 0.14285714285714285,\n 'exp': 0.14285714285714285,\n 'log': 0.14285714285714285,\n 'sin': 0.14285714285714285,\n 'sqrt': 0.14285714285714285,\n 'tan': 0.14285714285714285}\n</code></pre> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def prior_from_space(space):\n    \"\"\"\n    Uniform prior from a list of strings\n    Examples:\n        &gt;&gt;&gt; import pprint\n        &gt;&gt;&gt; operator_space = ['+', '-', '*', '/', '^']\n        &gt;&gt;&gt; operator_prior = prior_from_space(operator_space)\n        &gt;&gt;&gt; pprint.pprint(operator_prior)\n        {'*': 0.2, '+': 0.2, '-': 0.2, '/': 0.2, '^': 0.2}\n\n        &gt;&gt;&gt; function_space = ['sin', 'cos', 'tan', 'exp', 'log', 'sqrt', 'abs']\n        &gt;&gt;&gt; function_prior = prior_from_space(function_space)\n        &gt;&gt;&gt; pprint.pprint(function_prior)\n        {'abs': 0.14285714285714285,\n         'cos': 0.14285714285714285,\n         'exp': 0.14285714285714285,\n         'log': 0.14285714285714285,\n         'sin': 0.14285714285714285,\n         'sqrt': 0.14285714285714285,\n         'tan': 0.14285714285714285}\n    \"\"\"\n    return priors_from_space(space)\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.re_normalize","title":"<code>re_normalize(target, origin)</code>","text":"Source code in <code>src/equation_tree/prior.py</code> <pre><code>def re_normalize(target, origin):\n    \"\"\" \"\"\"\n    tmp_t = copy.deepcopy(target)\n    tmp_o = copy.deepcopy(origin)\n\n    def _rec_re_normalize(t, p):\n        for k, val in t.items():\n            if isinstance(val, dict) and isinstance(p[k], dict):\n                _rec_re_normalize(t[k], p[k])\n            elif not isinstance(val, dict):\n                if not isinstance(p[k], dict) and val &lt;= 0 &lt; p[k]:\n                    t[k] = MIN\n                elif val &lt;= 0:\n                    t[k] = 0\n\n    _rec_re_normalize(tmp_t, tmp_o)\n    normalize(tmp_t)\n    return tmp_t\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.scalar_multiply","title":"<code>scalar_multiply(scalar, prior)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; m = {'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': .1, 'b_2': .3}}\n&gt;&gt;&gt; s = 2\n&gt;&gt;&gt; pprint.pprint(scalar_multiply(s, m))\n{'a': {'a_1': 6, 'a_2': 4}, 'b': {'b_1': 0.2, 'b_2': 0.6}}\n</code></pre> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def scalar_multiply(scalar, prior):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pprint\n        &gt;&gt;&gt; m = {'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': .1, 'b_2': .3}}\n        &gt;&gt;&gt; s = 2\n        &gt;&gt;&gt; pprint.pprint(scalar_multiply(s, m))\n        {'a': {'a_1': 6, 'a_2': 4}, 'b': {'b_1': 0.2, 'b_2': 0.6}}\n    \"\"\"\n    tmp_p = copy.deepcopy(prior)\n\n    def _rec_s_mult(s, p):\n        for k, val in p.items():\n            if isinstance(val, dict):\n                _rec_s_mult(s, p[k])\n            else:\n                p[k] *= s\n\n    _rec_s_mult(scalar, tmp_p)\n    return tmp_p\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.structure_prior_from_depth","title":"<code>structure_prior_from_depth(depth)</code>","text":"<p>Uniform structure prior for a given depth Examples:     &gt;&gt;&gt; import pprint     &gt;&gt;&gt; pprint.pprint(structure_prior_from_depth(3))     {'[0, 1, 1]': 0.5, '[0, 1, 2]': 0.5}     &gt;&gt;&gt; pprint.pprint(structure_prior_from_depth(4))     {'[0, 1, 1, 2]': 0.25,      '[0, 1, 2, 1]': 0.25,      '[0, 1, 2, 2]': 0.25,      '[0, 1, 2, 3]': 0.25}</p> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def structure_prior_from_depth(depth):\n    \"\"\"\n    Uniform structure prior for a given depth\n    Examples:\n        &gt;&gt;&gt; import pprint\n        &gt;&gt;&gt; pprint.pprint(structure_prior_from_depth(3))\n        {'[0, 1, 1]': 0.5, '[0, 1, 2]': 0.5}\n        &gt;&gt;&gt; pprint.pprint(structure_prior_from_depth(4))\n        {'[0, 1, 1, 2]': 0.25,\n         '[0, 1, 2, 1]': 0.25,\n         '[0, 1, 2, 2]': 0.25,\n         '[0, 1, 2, 3]': 0.25}\n\n    \"\"\"\n    structures = _gen_tree_structures(depth)\n    structures = [s for s in structures if len(s) == depth]\n    return prior_from_space([str(s) for s in structures])\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.structure_prior_from_max_depth","title":"<code>structure_prior_from_max_depth(max_depth)</code>","text":"<p>Uniform structure prior up to a given depth (from min depth 3) Examples:     &gt;&gt;&gt; import pprint     &gt;&gt;&gt; pprint.pprint(structure_prior_from_max_depth(3))     {'[0, 1, 1]': 0.5, '[0, 1, 2]': 0.5}     &gt;&gt;&gt; pprint.pprint(structure_prior_from_max_depth(4))     {'[0, 1, 1, 2]': 0.16666666666666666,      '[0, 1, 1]': 0.16666666666666666,      '[0, 1, 2, 1]': 0.16666666666666666,      '[0, 1, 2, 2]': 0.16666666666666666,      '[0, 1, 2, 3]': 0.16666666666666666,      '[0, 1, 2]': 0.16666666666666666}     &gt;&gt;&gt; pprint.pprint(structure_prior_from_max_depth(5))     {'[0, 1, 1, 2, 2]': 0.06666666666666667,      '[0, 1, 1, 2, 3]': 0.06666666666666667,      '[0, 1, 1, 2]': 0.06666666666666667,      '[0, 1, 1]': 0.06666666666666667,      '[0, 1, 2, 1, 2]': 0.06666666666666667,      '[0, 1, 2, 1]': 0.06666666666666667,      '[0, 1, 2, 2, 1]': 0.06666666666666667,      '[0, 1, 2, 2, 3]': 0.06666666666666667,      '[0, 1, 2, 2]': 0.06666666666666667,      '[0, 1, 2, 3, 1]': 0.06666666666666667,      '[0, 1, 2, 3, 2]': 0.06666666666666667,      '[0, 1, 2, 3, 3]': 0.06666666666666667,      '[0, 1, 2, 3, 4]': 0.06666666666666667,      '[0, 1, 2, 3]': 0.06666666666666667,      '[0, 1, 2]': 0.06666666666666667}</p> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def structure_prior_from_max_depth(max_depth):\n    \"\"\"\n    Uniform structure prior up to a given depth (from min depth 3)\n    Examples:\n        &gt;&gt;&gt; import pprint\n        &gt;&gt;&gt; pprint.pprint(structure_prior_from_max_depth(3))\n        {'[0, 1, 1]': 0.5, '[0, 1, 2]': 0.5}\n        &gt;&gt;&gt; pprint.pprint(structure_prior_from_max_depth(4))\n        {'[0, 1, 1, 2]': 0.16666666666666666,\n         '[0, 1, 1]': 0.16666666666666666,\n         '[0, 1, 2, 1]': 0.16666666666666666,\n         '[0, 1, 2, 2]': 0.16666666666666666,\n         '[0, 1, 2, 3]': 0.16666666666666666,\n         '[0, 1, 2]': 0.16666666666666666}\n        &gt;&gt;&gt; pprint.pprint(structure_prior_from_max_depth(5))\n        {'[0, 1, 1, 2, 2]': 0.06666666666666667,\n         '[0, 1, 1, 2, 3]': 0.06666666666666667,\n         '[0, 1, 1, 2]': 0.06666666666666667,\n         '[0, 1, 1]': 0.06666666666666667,\n         '[0, 1, 2, 1, 2]': 0.06666666666666667,\n         '[0, 1, 2, 1]': 0.06666666666666667,\n         '[0, 1, 2, 2, 1]': 0.06666666666666667,\n         '[0, 1, 2, 2, 3]': 0.06666666666666667,\n         '[0, 1, 2, 2]': 0.06666666666666667,\n         '[0, 1, 2, 3, 1]': 0.06666666666666667,\n         '[0, 1, 2, 3, 2]': 0.06666666666666667,\n         '[0, 1, 2, 3, 3]': 0.06666666666666667,\n         '[0, 1, 2, 3, 4]': 0.06666666666666667,\n         '[0, 1, 2, 3]': 0.06666666666666667,\n         '[0, 1, 2]': 0.06666666666666667}\n    \"\"\"\n    structures = _gen_tree_structures(max_depth)\n    return prior_from_space([str(s) for s in structures])\n</code></pre>"},{"location":"reference/src/equation_tree/prior/#src.equation_tree.prior.subtract","title":"<code>subtract(minuend, subtrahend)</code>","text":"<p>Minuend - Subtrahend Examples:     &gt;&gt;&gt; import pprint     &gt;&gt;&gt; m = {'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': .1, 'b_2': .3}}     &gt;&gt;&gt; s = {'a': {'a_1': 2, 'a_2': 4}}     &gt;&gt;&gt; pprint.pprint(subtract(m, s))     {'a': {'a_1': 1, 'a_2': -2}, 'b': {'b_1': 0.0, 'b_2': 0.0}}</p> Source code in <code>src/equation_tree/prior.py</code> <pre><code>def subtract(minuend, subtrahend):\n    \"\"\"\n    Minuend - Subtrahend\n    Examples:\n        &gt;&gt;&gt; import pprint\n        &gt;&gt;&gt; m = {'a': {'a_1': 3, 'a_2': 2}, 'b': {'b_1': .1, 'b_2': .3}}\n        &gt;&gt;&gt; s = {'a': {'a_1': 2, 'a_2': 4}}\n        &gt;&gt;&gt; pprint.pprint(subtract(m, s))\n        {'a': {'a_1': 1, 'a_2': -2}, 'b': {'b_1': 0.0, 'b_2': 0.0}}\n\n    \"\"\"\n    tmp_m = copy.deepcopy(minuend)\n    tmp_s = copy.deepcopy(subtrahend)\n\n    def _rec_sub(m, s):\n        for k, val in m.items():\n            if k in s.keys():\n                if isinstance(val, dict) and isinstance(s[k], dict):\n                    _rec_sub(val, s[k])\n                elif (\n                    not isinstance(val, dict)\n                    and is_numeric(val)\n                    and not isinstance(s[k], dict)\n                    and is_numeric(s[k])\n                ):\n                    m[k] -= s[k]\n                else:\n                    if not isinstance(val, dict):\n                        m[k] = 0.0\n                    else:\n                        _set_zero(m[k])\n            else:\n                if not isinstance(val, dict):\n                    m[k] = 0.0\n                else:\n                    _set_zero(m[k])\n\n    _rec_sub(tmp_m, tmp_s)\n    return tmp_m\n</code></pre>"},{"location":"reference/src/equation_tree/sample/","title":"Sample","text":""},{"location":"reference/src/equation_tree/sample/#src.equation_tree.sample.sample_tree_raw_from_priors","title":"<code>sample_tree_raw_from_priors(max_num_constants=0, max_num_variables=1, feature_priors=None, function_priors=DEFAULT_FUNCTION_SPACE, operator_priors=DEFAULT_OPERATOR_SPACE, structure_priors={})</code>","text":"<p>Sample a tree from priors, simplify and check if valid tree</p> Source code in <code>src/equation_tree/sample.py</code> <pre><code>def sample_tree_raw_from_priors(\n    max_num_constants: int = 0,\n    max_num_variables: int = 1,\n    feature_priors: Optional[Dict] = None,\n    function_priors: PriorType = DEFAULT_FUNCTION_SPACE,\n    operator_priors: PriorType = DEFAULT_OPERATOR_SPACE,\n    structure_priors: PriorType = {},\n):\n    \"\"\"\n    Sample a tree from priors, simplify and check if valid tree\n    \"\"\"\n    # Assertions\n    if max_num_constants + max_num_variables &lt; 1:\n        raise Exception(\"Can not sample tree without leafs\")\n\n    # Get feature priors\n    if feature_priors is not None:\n        for key in feature_priors:\n            if not (is_variable_formatted(key) or is_constant_formatted(key)):\n                raise Exception(\n                    \"Use standard formats for feature priors: x_{int} for variables, \"\n                    \"c_{int} for constants.\"\n                )\n        _feature_priors = feature_priors.copy()\n    else:\n        _feature_space = [f\"x_{i}\" for i in range(1, max_num_variables + 1)] + [\n            f\"c_{i}\" for i in range(1, max_num_constants + 1)\n        ]\n        _feature_priors = priors_from_space(_feature_space)\n\n    # Convert priors if space is given\n    if isinstance(function_priors, List):\n        _function_priors = priors_from_space(function_priors)\n    else:\n        _function_priors = function_priors.copy()\n\n    if isinstance(operator_priors, List):\n        _operator_priors = priors_from_space(operator_priors)\n    else:\n        _operator_priors = operator_priors.copy()\n\n    if isinstance(structure_priors, List):\n        _structure_priors = priors_from_space(structure_priors)\n    else:\n        _structure_priors = structure_priors.copy()\n\n    # Create tree\n    equation_tree = EquationTree.from_priors(\n        feature_priors=_feature_priors,\n        function_priors=_function_priors,\n        operator_priors=_operator_priors,\n        structure_priors=_structure_priors,\n    )\n\n    # Check if tree is valid\n    if not equation_tree.check_validity():\n        return None\n\n    equation_tree.simplify(\n        function_test=lambda x: x in _function_priors.keys(),\n        operator_test=lambda x: x in _operator_priors.keys(),\n    )\n\n    # Check is nan\n    if equation_tree.is_nan:\n        return None\n\n    # Check if duplicate constants\n    if (\n        equation_tree.n_non_numeric_constants\n        &gt; equation_tree.n_non_numeric_constants_unique\n    ):\n        return None\n\n    # Check if more constants than max:\n    if equation_tree.n_constants &gt; max_num_constants:\n        return None\n\n    # Check if more variables than max:\n    if equation_tree.n_variables &gt; max_num_variables:\n        return None\n\n    if not equation_tree.check_validity():\n        return None\n\n    if not equation_tree.check_possible(\n        _feature_priors, _function_priors, _operator_priors, _structure_priors\n    ):\n        return None\n\n    equation_tree.get_evaluation()\n    if not equation_tree.has_valid_value:\n        return None\n\n    return equation_tree\n</code></pre>"},{"location":"reference/src/equation_tree/tree/","title":"Tree","text":""},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree","title":"<code>EquationTree</code>","text":"<p>Equation tree that represents an equation as binary tree.</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>class EquationTree:\n    \"\"\"\n    Equation tree that represents an equation as binary tree.\n    \"\"\"\n\n    def __init__(self, node: TreeNode):\n        \"\"\"\n        Initializes a tree from a TreeNode\n\n        Examples:\n            # We can inititlize from a single node\n            &gt;&gt;&gt; node_root = TreeNode(kind=NodeKind.VARIABLE, attribute=\"x\")\n            &gt;&gt;&gt; equation_tree = EquationTree(node_root)\n            &gt;&gt;&gt; equation_tree.expr\n            ['x']\n            &gt;&gt;&gt; equation_tree.structure\n            [0]\n            &gt;&gt;&gt; equation_tree.variables\n            ['x']\n\n            # Or from a node with children\n            &gt;&gt;&gt; node_left = TreeNode(kind=NodeKind.VARIABLE, attribute=\"x\")\n            &gt;&gt;&gt; node_right = TreeNode(kind=NodeKind.CONSTANT, attribute=\"c\")\n            &gt;&gt;&gt; node_root = TreeNode(kind=NodeKind.OPERATOR, attribute=\"+\", \\\n                            left=node_left, right=node_right)\n            &gt;&gt;&gt; equation_tree = EquationTree(node_root)\n            &gt;&gt;&gt; equation_tree.expr\n            ['+', 'x', 'c']\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 1]\n            &gt;&gt;&gt; equation_tree.variables\n            ['x']\n            &gt;&gt;&gt; equation_tree.constants\n            ['c']\n            &gt;&gt;&gt; equation_tree.operators\n            ['+']\n\n            # We can first sample a node and children and initialize from that\n            &gt;&gt;&gt; np.random.seed(42)\n            &gt;&gt;&gt; max_depth = 12\n            &gt;&gt;&gt; structure_priors = {'[0, 1, 2, 1, 2, 3]': .5, '[0, 1, 2, 2, 1, 2, 3]': .5}\n            &gt;&gt;&gt; feature_priors = {\"x_1\": 0.5, \"c_1\": 0.5}\n            &gt;&gt;&gt; function_priors = {\"sin\": 0.5, \"cos\": 0.5}\n            &gt;&gt;&gt; operator_priors = {\"+\": 0.5, \"-\": 0.5}\n            &gt;&gt;&gt; node_root = sample_tree(feature_priors, function_priors,\n            ...     operator_priors, structure_priors)\n            &gt;&gt;&gt; equation_tree = EquationTree(node_root)\n            &gt;&gt;&gt; equation_tree.expr\n            ['-', 'cos', 'c_1', 'sin', 'sin', 'x_1']\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 2, 1, 2, 3]\n            &gt;&gt;&gt; equation_tree.variables\n            ['x_1']\n            &gt;&gt;&gt; equation_tree.n_variables\n            1\n            &gt;&gt;&gt; equation_tree.n_variables_unique\n            1\n            &gt;&gt;&gt; equation_tree.constants\n            ['c_1']\n            &gt;&gt;&gt; equation_tree.n_constants\n            1\n            &gt;&gt;&gt; equation_tree.n_constants_unique\n            1\n            &gt;&gt;&gt; equation_tree.n_leafs\n            2\n            &gt;&gt;&gt; equation_tree.operators\n            ['-']\n            &gt;&gt;&gt; equation_tree.functions\n            ['cos', 'sin', 'sin']\n\n            # First we create test functions that test weather an attribute is a variable,\n            # a constant, a function, or an operater\n            &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y', 'z']\n            &gt;&gt;&gt; is_constant = lambda x : x in ['0', '1', '2']\n            &gt;&gt;&gt; is_function = lambda x : x in ['sin', 'cos']\n            &gt;&gt;&gt; is_operator = lambda x: x in ['+', '-', '*', '/']\n\n            # here we use the prefix notation\n            &gt;&gt;&gt; prefix_notation = ['+', '-', 'x', '1', '*', 'sin', 'y', 'cos', 'z']\n\n            # then we create the node root\n            &gt;&gt;&gt; node_root = node_from_prefix(\n            ...     prefix_notation=prefix_notation,\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant,\n            ...     function_test=is_function,\n            ...     operator_test=is_operator\n            ...     )\n\n            # and initialize the tree\n            &gt;&gt;&gt; equation_tree = EquationTree(node_root)\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 2, 2, 1, 2, 3, 2, 3]\n            &gt;&gt;&gt; equation_tree.variables\n            ['x', 'y', 'z']\n            &gt;&gt;&gt; equation_tree.constants\n            ['1']\n            &gt;&gt;&gt; equation_tree.operators\n            ['+', '-', '*']\n            &gt;&gt;&gt; equation_tree.functions\n            ['sin', 'cos']\n\n            # The tree expression is the same as the prefix notation\n            &gt;&gt;&gt; equation_tree.expr == prefix_notation\n            True\n        \"\"\"\n\n        self.root: Union[TreeNode, None] = node\n\n        self.structure: List[int] = []\n\n        self.expr: List[str] = list()\n\n        self.variables: List[str] = list()\n        self.functions: List[str] = list()\n        self.operators: List[str] = list()\n        self.constants: List[str] = list()\n\n        self.evaluation = None\n\n        self._build()\n\n    @classmethod\n    def from_prefix(\n        cls,\n        prefix_notation: List[str],\n        function_test: Callable = lambda _: False,\n        operator_test: Callable = lambda _: False,\n        variable_test: Callable = lambda _: False,\n        constant_test: Callable = lambda _: False,\n    ):\n        \"\"\"\n        Instantiate a tree from prefix notation\n\n        Args:\n            prefix_notation: The equation in prefix notation\n            function_test: A function that tests if the attribute is a function\n            operator_test: A function that tests if the attribute is an operator\n            variable_test: A function that tests if the attribute is a variable\n            constant_test: A function that tests if the attribute is a constant\n\n        Example:\n            &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y', 'z']\n            &gt;&gt;&gt; is_constant = lambda x : x in ['0', '1', '2']\n            &gt;&gt;&gt; is_function = lambda x : x in ['sin', 'cos']\n            &gt;&gt;&gt; is_operator = lambda x: x in ['+', '-', '*', '/']\n            &gt;&gt;&gt; prefix = ['+', '-', 'x', '1', '*', 'sin', 'y', 'cos', 'z']\n\n            # then we create the node root\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n            ...     prefix_notation=prefix,\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant,\n            ...     function_test=is_function,\n            ...     operator_test=is_operator\n            ...     )\n\n            # and initialize the tree\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 2, 2, 1, 2, 3, 2, 3]\n            &gt;&gt;&gt; equation_tree.variables\n            ['x', 'y', 'z']\n            &gt;&gt;&gt; equation_tree.constants\n            ['1']\n            &gt;&gt;&gt; equation_tree.operators\n            ['+', '-', '*']\n            &gt;&gt;&gt; equation_tree.functions\n            ['sin', 'cos']\n\n            # The tree expression is the same as the prefix notation\n            &gt;&gt;&gt; equation_tree.expr == prefix\n            True\n\n\n        \"\"\"\n        root = node_from_prefix(\n            prefix_notation, function_test, operator_test, variable_test, constant_test\n        )\n        return cls(root)\n\n    @classmethod\n    def from_full_prior(cls, prior):\n        root = sample_tree_full(prior)\n        return cls(root)\n\n    @classmethod\n    def from_prior_fast(cls, prior: Dict, tree_depth, max_variables_unique: int):\n        \"\"\"\n        Initiate a tree from a prior with fast sampling\n        Attention: structure prior is not supported\n\n        Args:\n            prior: The priors in dictionary form (structure priors are not needed)\n            tree_depth: depth of the tree\n            max_variables_unique: The maximum number of unique variables (a tree can have less then\n                this number)\n        \"\"\"\n        root = sample_tree_full_fast(prior, tree_depth, max_variables_unique)\n        return cls(root)\n\n    @classmethod\n    def from_prior(cls, prior: Dict, max_variables_unique: int):\n        \"\"\"\n        Initiate a tree from a prior\n\n        Args:\n            prior: The priors in dictionary form\n            max_variables_unique: The maximum number of unique variables (a tree can have less then\n                this number)\n\n        Examples:\n            &gt;&gt;&gt; np.random.seed(42)\n\n            # We can set priors for features, functions, operators\n            # and also conditionals based the parent\n            &gt;&gt;&gt; p = {\n            ...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n            ...     'features': {'constants': .2, 'variables': .8},\n            ...     'functions': {'sin': .5, 'cos': .5},\n            ...     'operators': {'+': 1., '-': .0},\n            ...     'function_conditionals': {\n            ...                             'sin': {\n            ...                                 'features': {'constants': 0., 'variables': 1.},\n            ...                                 'functions': {'sin': 0., 'cos': 1.},\n            ...                                 'operators': {'+': 0., '-': 1.}\n            ...                             },\n            ...                             'cos': {\n            ...                                 'features': {'constants': 0., 'variables': 1.},\n            ...                                 'functions': {'cos': 1., 'sin': 0.},\n            ...                                 'operators': {'+': 0., '-': 1.}\n            ...                             }\n            ...                         },\n            ...     'operator_conditionals': {\n            ...                             '+': {\n            ...                                 'features': {'constants': .5, 'variables': .5},\n            ...                                 'functions': {'sin': 1., 'cos': 0.},\n            ...                                 'operators': {'+': 1., '-': 0.}\n            ...                             },\n            ...                             '-': {\n            ...                                 'features': {'constants': .3, 'variables': .7},\n            ...                                 'functions': {'cos': .5, 'sin': .5},\n            ...                                 'operators': {'+': .9, '-': .1}\n            ...                             }\n            ...                         },\n            ... }\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 2]\n            &gt;&gt;&gt; equation_tree.expr\n            ['cos', 'cos', 'x_1']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 2]\n            &gt;&gt;&gt; equation_tree.expr\n            ['sin', 'cos', 'x_1']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 1]\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 2, 3, 2, 3, 1]\n            &gt;&gt;&gt; equation_tree.expr\n            ['+', '+', 'sin', 'x_1', 'sin', 'x_2', 'x_2']\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            x_2 + sin(x_1) + sin(x_2)\n\n            # Without conditionals, the unconditioned priors are the fallback option\n            &gt;&gt;&gt; p = {\n            ...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n            ...     'features': {'constants': .2, 'variables': .8},\n            ...     'functions': {'sin': .5, 'cos': .5},\n            ...     'operators': {'+': .5, '-': .5},\n            ... }\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 2, 3, 2, 3, 1]\n            &gt;&gt;&gt; equation_tree.expr\n            ['+', '-', 'cos', 'c_1', 'cos', 'c_2', 'c_3']\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            c_3 + cos(c_1) - cos(c_2)\n\n            # Note: this would be discarded in a future step as unnecesarry complex\n        \"\"\"\n        root = sample_tree_full(prior, max_variables_unique)\n        return cls(root)\n\n    @classmethod\n    def from_priors(\n        cls,\n        feature_priors={},\n        function_priors={},\n        operator_priors={},\n        structure_priors={},\n    ):\n        \"\"\"\n        Instantiate a tree from priors\n\n        Attention\n            - use standard notation here:   variables should be in form x_{number}\n                                            constants should be in form c_{number}\n\n        Args:\n            max_depth: Maximum depth of the tree\n            feature_priors: The priors for the features (variables + constants)\n            function_priors: The priors for the functions\n            operator_priors: The priors for the operators\n            structure_priors: The priors for the tree structures\n\n        Example:\n            &gt;&gt;&gt; np.random.seed(42)\n            &gt;&gt;&gt; max_depth = 12\n            &gt;&gt;&gt; feature_priors = {\"x_1\": 0.5, \"c_1\": 0.5}\n            &gt;&gt;&gt; function_priors = {\"sin\": 0.5, \"cos\": 0.5}\n            &gt;&gt;&gt; operator_priors = {\"+\": 0.5, \"-\": 0.5}\n            &gt;&gt;&gt; structure_priors = {'[0, 1, 2, 3, 4, 5, 5, 2, 3, 4, 4]': 1}\n            &gt;&gt;&gt; equation_tree = EquationTree.from_priors(\n            ...     feature_priors, function_priors, operator_priors, structure_priors)\n            &gt;&gt;&gt; equation_tree.expr\n            ['cos', '-', 'cos', 'sin', '+', 'x_1', 'c_1', 'cos', '-', 'x_1', 'c_1']\n            &gt;&gt;&gt; equation_tree.structure\n            [0, 1, 2, 3, 4, 5, 5, 2, 3, 4, 4]\n            &gt;&gt;&gt; equation_tree.variables\n            ['x_1', 'x_1']\n            &gt;&gt;&gt; equation_tree.n_variables\n            2\n            &gt;&gt;&gt; equation_tree.n_variables_unique\n            1\n            &gt;&gt;&gt; equation_tree.constants\n            ['c_1', 'c_1']\n            &gt;&gt;&gt; equation_tree.n_constants\n            2\n            &gt;&gt;&gt; equation_tree.n_constants_unique\n            1\n            &gt;&gt;&gt; equation_tree.n_leafs\n            4\n            &gt;&gt;&gt; equation_tree.operators\n            ['-', '+', '-']\n            &gt;&gt;&gt; equation_tree.functions\n            ['cos', 'cos', 'sin', 'cos']\n        \"\"\"\n        root = sample_tree(\n            feature_priors,\n            function_priors,\n            operator_priors,\n            structure_priors,\n        )\n        return cls(root)\n\n    @classmethod\n    def from_sympy(\n        cls,\n        expression,\n        function_test: Callable = lambda _: False,\n        operator_test: Callable = lambda _: False,\n        variable_test: Callable = lambda _: False,\n        constant_test: Callable = lambda _: False,\n    ):\n        \"\"\"\n        Instantiate a tree from a sympy function\n\n        Attention:\n            - constant and variable names get standardized\n            - unary minus get converted to binary minus\n\n        Examples:\n            &gt;&gt;&gt; expr = sympify('x_a + B * y')\n            &gt;&gt;&gt; expr\n            B*y + x_a\n            &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*']\n            &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['y']\n            &gt;&gt;&gt; is_constant = lambda x : x == 'B'\n            &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n            ...     expr,\n            ...     operator_test=is_operator,\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant\n            ... )\n            &gt;&gt;&gt; equation_tree.expr\n            ['+', '*', 'c_1', 'x_2', 'x_1']\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            c_1*x_2 + x_1\n\n            # Numbers don't get standardized but are constants\n            &gt;&gt;&gt; expr = sympify('x_a + 2 * y')\n            &gt;&gt;&gt; expr\n            x_a + 2*y\n            &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n            ...     expr,\n            ...     operator_test=is_operator,\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant\n            ... )\n            &gt;&gt;&gt; equation_tree.expr\n            ['+', 'x_1', '*', '2', 'x_2']\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            x_1 + 2*x_2\n            &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', '**']\n            &gt;&gt;&gt; is_variable = lambda x: '_' in x\n            &gt;&gt;&gt; is_constant = lambda x: x == 'B'\n            &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n            ...     sympify('B*x_1**2'),\n            ...     operator_test=is_operator,\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant\n            ... )\n\n            &gt;&gt;&gt; expr = sympify('min(x_1, x_2)')\n            &gt;&gt;&gt; expr\n            Min(x_1, x_2)\n            &gt;&gt;&gt; is_operator = lambda x : x in ['min']\n            &gt;&gt;&gt; is_variable = lambda x : x in ['x_1', 'x_2']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n            ...     expr,\n            ...     operator_test=is_operator,\n            ...     variable_test=is_variable,\n            ... )\n            &gt;&gt;&gt; equation_tree.expr\n            ['min', 'x_1', 'x_2']\n\n            &gt;&gt;&gt; expr = sympify('x_1**2')\n            &gt;&gt;&gt; expr\n            x_1**2\n            &gt;&gt;&gt; is_operator = lambda x : x in ['*', '/', '**', '+']\n            &gt;&gt;&gt; is_variable = lambda x : x in ['x_1']\n            &gt;&gt;&gt; is_function = lambda x : x in ['squared']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n            ...     expr,\n            ...     operator_test=is_operator,\n            ...     variable_test=is_variable,\n            ...     function_test=is_function\n            ... )\n            &gt;&gt;&gt; equation_tree.expr\n            ['squared', 'x_1']\n\n        \"\"\"\n        standard = standardize_sympy(expression, variable_test, constant_test)\n        standard = unary_minus_to_binary(standard, operator_test)\n        standard = op_const_to_func(standard)\n        prefix = infix_to_prefix(str(standard), function_test, operator_test)\n        root = node_from_prefix(\n            prefix,\n            function_test,\n            operator_test,\n            lambda x: \"x_\" in x,\n            lambda x: \"c_\" in x,\n        )\n        return cls(root)\n\n    @property\n    def constants_unique(self):\n        return list(set(self.constants))\n\n    @property\n    def n_constants(self):\n        return len(self.constants)\n\n    @property\n    def n_constants_unique(self):\n        return len(set(self.constants))\n\n    @property\n    def non_numeric_constants(self):\n        return [\n            c for c in self.constants if not is_numeric(c) and not is_known_constant(c)\n        ]\n\n    @property\n    def non_numeric_constants_unique(self):\n        return list(set(self.non_numeric_constants))\n\n    @property\n    def n_non_numeric_constants_unique(self):\n        return len(self.non_numeric_constants_unique)\n\n    @property\n    def n_non_numeric_constants(self):\n        return len(self.non_numeric_constants)\n\n    @property\n    def variables_unique(self):\n        return list(set(self.variables))\n\n    @property\n    def n_variables(self):\n        return len(self.variables)\n\n    @property\n    def n_variables_unique(self):\n        return len(set(self.variables))\n\n    @property\n    def functions_unique(self):\n        return list(set(self.functions))\n\n    @property\n    def operators_unique(self):\n        return list(set(self.operators))\n\n    @property\n    def n_leafs(self):\n        return self.n_constants + self.n_variables\n\n    # TODO: implement this\n    @property\n    def standard_structure(self):\n        return self.structure\n\n    @property\n    def prefix(self):\n        return self.expr\n\n    @property\n    def infix(self):\n        return prefix_to_infix(\n            self.prefix, lambda x: x in self.functions, lambda x: x in self.operators\n        )\n\n    @property\n    def sympy_expr(self):\n        _infix = func_to_op_const(self.infix)\n        sympy_expr = sympify(_infix)\n        if sympy_expr.free_symbols:\n            symbol_names = [str(symbol) for symbol in sympy_expr.free_symbols]\n            real_symbols = symbols(\" \".join(symbol_names), real=True)\n            if not isinstance(real_symbols, list) and not isinstance(\n                real_symbols, tuple\n            ):\n                real_symbols = [real_symbols]\n            subs_dict = {old: new for old, new in zip(symbol_names, real_symbols)}\n            sympy_expr = sympy_expr.subs(subs_dict)\n        return sympy_expr\n\n    @property\n    def is_nan(self):\n        return self.root is None\n\n    @property\n    def value_samples_as_df(self):\n        if self.evaluation is None:\n            warnings.warn(\n                \"Tree not yet evaluated. Use method get_evaluation to evaluate the tree\"\n            )\n            return None\n        data = {\"observation\": self.evaluation[:, 0]}\n        for idx, key in enumerate(self.expr):\n            if key in self.variables:\n                data[key] = self.evaluation[:, idx]\n            if key in self.non_numeric_constants:\n                data[key] = self.evaluation[:, idx]\n        return pd.DataFrame(data)\n\n    @property\n    def has_valid_value(self):\n        if self.evaluation is None:\n            warnings.warn(\n                \"Tree not yet evaluated. Use method get_evaluation to evaluate the tree\"\n            )\n            return False\n        ev = self.evaluation[0, :]\n        return np.any(np.isfinite(ev) &amp; ~np.isnan(ev))\n\n    @property\n    def info(self):\n        \"\"\"\n        Get al information as dictionary\n        \"\"\"\n        info = {}\n        info[\"max_depth\"] = len(self.structure)\n        info[\"depth\"] = max(self.structure)\n        info[\"structures\"] = self.structure\n        info[\"features\"] = {\n            \"constants\": self.n_constants,\n            \"variables\": self.n_variables,\n        }\n        functions = {}\n        function_conditionals = {key: {} for key in self.functions_unique}\n        for f in self.functions_unique:\n            functions[f] = len([_f for _f in self.functions if _f == f])\n            p_functions, p_operators, p_features = self._get_conditionals(f)\n            function_conditionals[f][\"functions\"] = p_functions\n            function_conditionals[f][\"operators\"] = p_operators\n            function_conditionals[f][\"features\"] = p_features\n        operators = {}\n        operator_conditionals = {key: {} for key in self.operators_unique}\n        for o in self.operators_unique:\n            operators[o] = len([_o for _o in self.operators if _o == o])\n            p_functions, p_operators, p_features = self._get_conditionals(o)\n            operator_conditionals[o][\"functions\"] = p_functions\n            operator_conditionals[o][\"operators\"] = p_operators\n            operator_conditionals[o][\"features\"] = p_features\n        info[\"functions\"] = functions\n        info[\"function_conditionals\"] = function_conditionals\n        info[\"operators\"] = operators\n        info[\"operator_conditionals\"] = operator_conditionals\n        return info\n\n    def evaluate(self, variables: Union[dict, pd.DataFrame]):\n        \"\"\"\n        Examples:\n            &gt;&gt;&gt; expr = sympify('x_a + 3 * y')\n            &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*']\n            &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['y']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n            ...     expr,\n            ...     operator_test=is_operator,\n            ...     variable_test=is_variable,\n            ... )\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            x_1 + 3*x_2\n\n            # We can use dicts:\n            &gt;&gt;&gt; equation_tree.evaluate({'x_1': np.array([2, 3]), 'x_2': np.array([1, 1])})\n            array([5, 6])\n\n            # Or pandas dataframe:\n            &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': np.array([2, 3]), 'x_2': np.array([1, 1])})\n            &gt;&gt;&gt; dataFrame\n               x_1  x_2\n            0    2    1\n            1    3    1\n            &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n            array([5, 6])\n\n            # Or pandas dataframe:\n            &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [2, 3], 'x_2': [1, 1]})\n            &gt;&gt;&gt; dataFrame\n               x_1  x_2\n            0    2    1\n            1    3    1\n            &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n            array([5, 6])\n\n            &gt;&gt;&gt; expr = sympify('min(x_1,x_2)')\n            &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', 'min']\n            &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['x_1', 'x_2']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n            ...     expr,\n            ...     operator_test=is_operator,\n            ...     variable_test=is_variable,\n            ... )\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            Min(x_1, x_2)\n\n            &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [1, 2, 3, 4], 'x_2': [2, 1, 4, 3]})\n            &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n            array([1, 1, 3, 3])\n\n            &gt;&gt;&gt; expr = sympify('max(3, x_1)')\n            &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', 'min', 'max']\n            &gt;&gt;&gt; is_function = lambda x : x in ['sqrt', 'log', 'abs']\n            &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['x_1', 'x_2']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n            ...     expr,\n            ...     function_test=is_function,\n            ...     operator_test=is_operator,\n            ...     variable_test=is_variable)\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            Max(3, x_1)\n            &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [1, 2, 3, 4]})\n            &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n            array([3, 3, 3, 4])\n\n            &gt;&gt;&gt; expr = sympify('x_1 + sqrt(x_1)')\n            &gt;&gt;&gt; is_operator = lambda x : x in ['+']\n            &gt;&gt;&gt; is_function = lambda x: x in ['sqrt']\n            &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['x_1']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n            ...     expr,\n            ...     operator_test=is_operator,\n            ...     function_test=is_function,\n            ...     variable_test=is_variable,\n            ... )\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            sqrt(x_1) + x_1\n\n            &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [4, 9, 16]})\n            &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n            array([ 6., 12., 20.])\n        \"\"\"\n\n        df = pd.DataFrame(variables)\n        symbol_list = list(self.sympy_expr.free_symbols)\n\n        if set(list(df.columns)).issubset(set(symbol_list)):\n            raise Exception(\n                f\"Variables in expression {self.sympy_expr} \"\n                f\"do not match the given ones: {df.columns}\"\n            )\n\n        symbol_names = [str(s) for s in symbol_list]\n\n        f = sympy.lambdify(symbol_list, self.sympy_expr, \"numpy\")\n        try:\n            res = np.array(f(*[df[name] for name in symbol_names]))\n        except ValueError:  # Workaround till sympy gets updated\n            lst = [df[name] for name in symbol_names]\n            res = []\n            for i in range(len(lst[0])):\n                args = []\n                for j in range(len(lst)):\n                    args.append(lst[j].iloc[i])\n                res.append(f(*args))\n        return np.array(res)\n\n    def save_samples(\n        self,\n        path,\n        num_samples,\n        ranges: Optional[Dict] = None,\n        default_range: float = 10,\n        dv_name: str = \"y\",\n        random_state: Optional[int] = None,\n        compression: str = \"gzip\",\n    ):\n        \"\"\"\n        Creates a file with samples of ivs and dvs\n        Args:\n            path: The path were to store the file\n            num_samples: The number of samples\n            ranges: A dictionary with the ranges for the variables in form of a dict\n            default_range: Default range to fall back to if no range for a\n                specific variable is given\n            dv_name: The name to give to the observation\n            random_state: The random seed to be used\n            compression: Compression method\n        \"\"\"\n        if not path.endswith(\"gz\") and compression == \"gzip\":\n            warnings.warn(\n                f\"Compression is gzip but file {path} does not have the ending .gz\"\n            )\n        _ranges = {\n            key: (-default_range, default_range) for key in self.variables_unique\n        }\n        if ranges is not None:\n            for key in ranges.keys():\n                if key in _ranges.keys():\n                    _ranges[key] = ranges[key]\n\n        rng = np.random.default_rng(random_state)\n\n        def _get_conditions_once():\n            raw_conditions = {}\n            for key in _ranges.keys():\n                raw_conditions[key] = rng.uniform(*_ranges[key], size=num_samples)\n            return pd.DataFrame(raw_conditions)\n\n        conditions_ = pd.DataFrame(columns=self.variables_unique + [dv_name])\n        i = 0\n        while i &lt; 1_000_000 and len(conditions_.index) &lt; num_samples:\n            _sample = _get_conditions_once()\n            evaluation = self.evaluate(_sample)\n            _sample[dv_name] = evaluation\n            bad_indices = np.where(np.isnan(evaluation) | np.isinf(evaluation))[0]\n            _sample = _sample.drop(bad_indices)\n            conditions_ = pd.concat([conditions_, _sample], ignore_index=True)\n            i += 1\n            if i &gt;= 1_000_000:\n                break\n        conditions_ = conditions_.head(num_samples)\n        conditions_.to_csv(path, compression=compression, index=False, sep=\"\\t\")\n\n    def save_samples_srbench(\n        self,\n        path,\n        num_samples,\n        ranges: Optional[Dict] = None,\n        default_range: float = 10,\n        random_state: Optional[int] = None,\n    ):\n        self.save_samples(\n            path, num_samples, ranges, default_range, \"target\", random_state\n        )\n\n    def save_meta_srbench(self, path, name_dataset, name_target=\"y\"):\n        info = {}\n        info[\"dataset\"] = name_dataset\n        info[\"description\"] = name_target + \" = \" + str(self.sympy_expr)\n        info[\"source\"] = \"https://github.com/AutoResearch/equation-tree\"\n        info[\"publication\"] = \"Not yet implemented\"\n        info[\"task\"] = \"regression\"\n        info[\"keywords\"] = [\"abstract\", \"math\", \"symbolic regression\"]\n        info[\"target\"] = {\n            \"type\": \"continuous\",\n            \"description\": \"abstract dependent variable\",\n        }\n        info[\"features\"] = [\n            {\n                \"name\": v,\n                \"type\": \"continuous\",\n                \"description\": \"abstract independent variable\",\n            }\n            for v in self.variables_unique\n        ]\n\n        with open(path, \"w\") as f:\n            yaml.dump(info, f, sort_keys=False)\n\n    def export_to_srbench(\n        self,\n        folder: str,\n        data_file_name: Optional[str] = None,\n        num_samples: int = 1000,\n        name_target: str = \"y\",\n        ranges: Optional[Dict] = None,\n        default_range: float = 10,\n        random_state: Optional[int] = None,\n    ):\n        \"\"\"\n        Creates a folder and adds data and metadata to the folder that can be used with sr bench:\n        https://cavalab.org/srbench/\n        Args:\n            folder: Name of the folder\n            data_file_name: Name of the datafile (if none same as folder name)\n            num_samples: Number of samples\n            name_target: Name of the tartget\n            ranges: A dictionary with the ranges for the variables in form of a dict\n            default_range: Default range to fall back to if no range for a\n                specific variable is given\n            random_state: The random seed to be used\n        \"\"\"\n        if data_file_name is None:\n            data_file_name = folder\n        os.mkdir(folder)\n        path_data = f\"{folder}/{data_file_name}.tsv.gz\"\n        path_meta = f\"{folder}/metadata.yaml\"\n        self.save_samples_srbench(\n            path_data, num_samples, ranges, default_range, random_state\n        )\n        self.save_meta_srbench(path_meta, \"data\", name_target)\n\n    def check_validity(\n        self,\n        zero_representations=[\"0\"],\n        log_representations=[\"log\", \"Log\"],\n        division_representations=[\"/\", \":\"],\n        verbose=False,\n    ):\n        \"\"\"\n        Check if the tree is valid:\n            - Check if log(0) or x / 0 exists\n            - Check if function(constant) or operator(constant_1, constant_2) exists\n                    -&gt; unnecessary complexity\n            - Check if each function has exactly one child\n            - Check if each operator has exactly two children\n\n        Args:\n            zero_representations: A list of attributes that represent zero\n            log_representations: A list of attributes that represent log\n            division_representations: A list of attributes that represent division\n            verbose: If set true, print out the reason for the invalid tree\n\n        Example:\n            &gt;&gt;&gt; is_variable = lambda x : x == 'x'\n            &gt;&gt;&gt; is_constant = lambda x : x == 'c' or x == '0'\n            &gt;&gt;&gt; is_operator = lambda x : x == '/'\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n            ...     ['/', 'x', '0'],\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant,\n            ...     operator_test=is_operator,\n            ... )\n            &gt;&gt;&gt; equation_tree.check_validity()\n            False\n            &gt;&gt;&gt; equation_tree.check_validity(verbose=True)\n            division by 0 is not allowed.\n            False\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n            ...     ['/', 'x', 'c'],\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant,\n            ...     operator_test=is_operator,\n            ... )\n            &gt;&gt;&gt; equation_tree.check_validity()\n            True\n\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n            ...     ['/', '0', 'c'],\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant,\n            ...     operator_test=is_operator,\n            ... )\n            &gt;&gt;&gt; equation_tree.check_validity(verbose=True)\n            0 and c are constants applied to the operator /\n            False\n        \"\"\"\n        return self.root.check_validity(\n            zero_representations, log_representations, division_representations, verbose\n        )\n\n    def draw_tree(self, out):\n        try:\n            from graphviz import Source\n        except ImportError:\n            print(\n                \"drawing uses requires `graphviz` to be installed: `pip install graphviz`\"\n            )\n        src = Source(dotprint(self.sympy_expr))\n        src.render(out, view=False)\n\n    def check_possible(\n        self,\n        feature_priors: Dict,\n        function_priors: Dict,\n        operator_priors: Dict,\n        structure_priors: Dict,\n    ):\n        \"\"\"\n        Check weather a tree is a possible tree given the priors\n        Attention:\n            If no prior is given, interpreted as all possibilities are allowed\n        \"\"\"\n        if feature_priors != {}:\n            for c in self.constants:\n                if c not in feature_priors.keys() or feature_priors[c] &lt;= 0:\n                    return False\n            for v in self.variables:\n                if v not in feature_priors.keys() or feature_priors[v] &lt;= 0:\n                    return False\n        if function_priors != {}:\n            for fun in self.functions:\n                if fun not in function_priors.keys() or function_priors[fun] &lt;= 0:\n                    return False\n        if operator_priors != {}:\n            for op in self.operators:\n                if op not in operator_priors.keys() or operator_priors[op] &lt;= 0:\n                    return False\n        if structure_priors != {}:\n            if (\n                str(self.structure) not in structure_priors.keys()\n                or structure_priors[str(self.structure)] &lt;= 0\n            ):\n                return False\n        return True\n\n    def check_possible_from_prior(self, prior: Dict):\n        structure_priors = prior[\"structures\"] if \"structures\" in prior.keys() else {}\n        feature_priors = prior[\"features\"] if \"features\" in prior.keys() else {}\n        function_priors = prior[\"functions\"] if \"functions\" in prior.keys() else {}\n        operator_priors = prior[\"operators\"] if \"operators\" in prior.keys() else {}\n        function_conditionals = (\n            prior[\"function_conditionals\"]\n            if \"function_conditionals\" in prior.keys()\n            else {}\n        )\n        operator_conditionals = (\n            prior[\"operator_conditionals\"]\n            if \"operator_conditionals\" in prior.keys()\n            else {}\n        )\n        if structure_priors:\n            if (\n                str(self.structure) not in structure_priors.keys()\n                or structure_priors[str(self.structure)] &lt;= 0\n            ):\n                return False\n        if feature_priors:\n            if (\n                self.n_variables &gt; 0\n                and (\n                    \"variables\" not in feature_priors.keys()\n                    or feature_priors[\"variables\"] &lt;= 0\n                )\n            ) or (\n                self.n_constants &gt; 0\n                and (\n                    \"constants\" not in feature_priors.keys()\n                    or feature_priors[\"constants\"] &lt;= 0\n                )\n            ):\n                return False\n        if function_priors:\n            for fun in self.functions_unique:\n                if fun not in function_priors.keys() or function_priors[fun] &lt;= 0:\n                    return False\n\n        if operator_priors:\n            for op in self.operators_unique:\n                if op not in operator_priors.keys() or operator_priors[op] &lt;= 0:\n                    return False\n\n        test_lst = []\n\n        def test_node(child):\n            nonlocal test_lst\n            if child is None or child.parent is None:\n                test_lst.append(True)\n                return\n            node = child.parent\n            _prior = {}\n            if (\n                node.kind == NodeKind.FUNCTION\n                and node.attribute in function_conditionals.keys()\n            ):\n                _prior = function_conditionals[node.attribute]\n            elif (\n                node.kind == NodeKind.OPERATOR\n                and node.attribute in operator_conditionals.keys()\n            ):\n                _prior = operator_conditionals[node.attribute]\n            if child.kind == NodeKind.FUNCTION:\n                _p = _prior[node.attribute][\"functions\"]\n                if (\n                    _p != {}\n                    and node.attribute not in _p.keys()\n                    or _p[node.attribute] &lt;= 0\n                ):\n                    test_lst.append(False)\n            elif child.kind == NodeKind.OPERATOR:\n                _p = _prior[node.attribute][\"operators\"]\n                if (\n                    _p != {}\n                    and node.attribute not in _p.keys()\n                    or _p[node.attribute] &lt;= 0\n                ):\n                    test_lst.append(False)\n            else:\n                _p = _prior[\"features\"] if \"features\" in _prior else {}\n                if child.kind == NodeKind.VARIABLE:\n                    if (\n                        _p != {}\n                        and \"variables\" not in _p.keys()\n                        or _p[\"variables\"] &lt;= 0\n                    ):\n                        test_lst.append(False)\n                if child.kind == NodeKind.CONSTANT:\n                    if (\n                        _p != {}\n                        and \"constants\" not in _p.keys()\n                        or _p[\"constants\"] &lt;= 0\n                    ):\n                        test_lst.append(False)\n            for c in child.children:\n                test_node(c)\n\n        conditionals = not any(item is False for item in test_lst)\n        if not conditionals:\n            return False\n        return True\n\n    def standardize(self):\n        \"\"\"\n        Standardize variable and constant names\n\n        Example:\n            &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y', 'z']\n            &gt;&gt;&gt; is_constant = lambda x : x in ['0', '1', '2']\n            &gt;&gt;&gt; is_function = lambda x : x in ['sin', 'cos']\n            &gt;&gt;&gt; is_operator = lambda x: x in ['+', '-', '*', '/']\n            &gt;&gt;&gt; prefix = ['+', '-', 'x', '1', '*', 'sin', 'y', 'cos', 'z']\n\n            # then we create the node root\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n            ...     prefix_notation=prefix,\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant,\n            ...     function_test=is_function,\n            ...     operator_test=is_operator\n            ...     )\n\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            x + sin(y)*cos(z) - 1\n\n            &gt;&gt;&gt; equation_tree.standardize()\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            x_1 + sin(x_2)*cos(x_3) - 1\n\n        \"\"\"\n        variable_count = 0\n        constant_count = 0\n        variables = {}\n        constants = {}\n\n        def rec_stand(node):\n            if node is None:\n                return\n            nonlocal variable_count, constant_count\n            nonlocal variables, constants\n            if node.kind == NodeKind.VARIABLE:\n                if node.attribute not in variables.keys():\n                    variable_count += 1\n                    variables[node.attribute] = f\"x_{variable_count}\"\n                node.attribute = variables[node.attribute]\n            if node.kind == NodeKind.CONSTANT and not is_numeric(node.attribute):\n                if node.attribute not in constants.keys():\n                    constant_count += 1\n                    constants[node.attribute] = f\"c_{constant_count}\"\n                node.attribute = constants[node.attribute]\n            else:\n                rec_stand(node.left)\n                rec_stand(node.right)\n            return node\n\n        self.root = rec_stand(self.root)\n        self._build()\n\n    def simplify(\n        self,\n        function_test: Union[Callable, None] = None,\n        operator_test: Union[Callable, None] = None,\n        is_binary_minus_only: bool = True,\n        is_power_caret: bool = True,\n        verbose: bool = False,\n    ):\n        \"\"\"\n        Simplify equation if the simplified equation has a shorter prefix\n        Args:\n            function_test: A function that tests weather an attribute is a function\n                Attention: simplifying may lead to new functions that were not in the equation\n                    before. If so, add this to the test here.\n            operator_test: A function that tests weather an attribute is an operator\n                Attention: simplifying may lead to new operators that were not in the equation\n                    before. If so, add this to the test here.\n            is_binary_minus_only: Convert all unary minus to binary after simplification\n            is_power_caret: Represent power as a caret after simplification\n            verbose: Show messages if simplification results in errors\n\n        Examples:\n            &gt;&gt;&gt; is_variable = lambda x: 'x_' in x\n            &gt;&gt;&gt; is_constant = lambda x: 'c_' in x or is_numeric(x) or is_known_constant(x)\n            &gt;&gt;&gt; is_operator = lambda x: x in ['+', '*', '/', '^', '-']\n            &gt;&gt;&gt; is_function = lambda x: x.lower() in ['sqrt', 'abs']\n            &gt;&gt;&gt; prefix_notation = ['+', 'x_1', 'x_1' ]\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n            ...     prefix_notation=prefix_notation,\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant,\n            ...     operator_test=is_operator,\n            ...     function_test=is_function)\n            &gt;&gt;&gt; equation_tree.expr\n            ['+', 'x_1', 'x_1']\n\n            # it takes care of multiplication:\n            &gt;&gt;&gt; equation_tree.simplify(function_test=is_function,operator_test=is_operator)\n            &gt;&gt;&gt; equation_tree.expr\n            ['*', '2', 'x_1']\n\n            &gt;&gt;&gt; prefix_notation = ['sqrt', '*', 'x_1', 'x_1']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n            ...     prefix_notation=prefix_notation,\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant,\n            ...     operator_test=is_operator,\n            ...     function_test=is_function)\n            &gt;&gt;&gt; equation_tree.expr\n            ['sqrt', '*', 'x_1', 'x_1']\n\n            # it is good practice to define tests at the begining of a script and use them\n            # throughout the project\n            &gt;&gt;&gt; equation_tree.simplify(\n            ...     operator_test=is_operator,\n            ...     function_test=is_function\n            ... )\n            &gt;&gt;&gt; equation_tree.expr\n            ['abs', 'x_1']\n\n            &gt;&gt;&gt; prefix_notation = ['*', '-', 'c_1', 'x_1', '-', 'x_1', 'c_1']\n            &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n            ...     prefix_notation=prefix_notation,\n            ...     variable_test=is_variable,\n            ...     constant_test=is_constant,\n            ...     operator_test=is_operator,\n            ...     function_test=is_function)\n            &gt;&gt;&gt; equation_tree.expr\n            ['*', '-', 'c_1', 'x_1', '-', 'x_1', 'c_1']\n\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            (-c_1 + x_1)*(c_1 - x_1)\n\n            # it is good practice to define tests at the begining of a script and use them\n            # throughout the project\n            &gt;&gt;&gt; equation_tree.simplify(\n            ...     operator_test=is_operator,\n            ...     function_test=is_function\n            ... )\n            &gt;&gt;&gt; equation_tree.sympy_expr\n            (-c_1 + x_1)**2\n\n            # &gt;&gt;&gt; equation_tree.expr\n            # ['^', '-', 'x_1', 'c_1', '2']\n        \"\"\"\n\n        if function_test is None:\n\n            def function_test(x):\n                return x in self.functions\n\n        else:\n            tmp_f = function_test\n\n            def function_test(x):\n                return tmp_f(x) or x in self.functions\n\n        if operator_test is None:\n\n            def operator_test(x):\n                return x in self.operators\n\n        else:\n            tmp_o = operator_test\n\n            def operator_test(x):\n                return tmp_o(x) or x in self.operators\n\n        class TimeoutError(Exception):\n            pass\n\n        def timeout_handler(signum, frame):\n            raise TimeoutError(\"Function call timed out\")\n\n        signal.signal(signal.SIGALRM, timeout_handler)\n        signal.alarm(SIMPLIFY_TIMEOUT)\n        try:\n            simplified_equation = simplify(self.sympy_expr)\n            signal.alarm(0)\n        except TimeoutError:\n            simplified_equation = self.sympy_expr\n        if not check_functions(simplified_equation, function_test):\n            warnings.warn(\n                f\"{simplified_equation} has functions that are not in function_test type\"\n            )\n            self.root = None\n            self._build()\n            return\n        if (\n            \"I\" in str(simplified_equation)\n            or \"accumbounds\" in str(simplified_equation).lower()\n        ):\n            if verbose:\n                print(f\"Simplify {str(self.sympy_expr)} results in complex values\")\n            self.root = None\n            self._build()\n            return\n        if is_power_caret:\n            simplified_equation = str(simplified_equation).replace(\"**\", \"^\")\n        simplified_equation = simplified_equation.replace(\"re\", \"\")\n        if is_binary_minus_only:\n            simplified_equation = unary_minus_to_binary(\n                simplified_equation, operator_test\n            )\n        simplified_equation = simplified_equation.replace(\" \", \"\")\n\n        prefix = infix_to_prefix(simplified_equation, function_test, operator_test)\n        if verbose:\n            print(\"prefix\", simplified_equation)\n            print(\"prefix tree\", prefix)\n        if \"re\" in prefix:\n            prefix.remove(\"re\")\n        if len(prefix) &gt; len(self.expr):\n            prefix = self.expr\n        if \"zoo\" in prefix or \"oo\" in prefix:\n            if verbose:\n                print(f\"Simplify {str(self.sympy_expr)} results in None\")\n            self.root = None\n            self._build()\n            return\n        self.root = node_from_prefix(\n            prefix,\n            function_test,\n            operator_test,\n            lambda x: x in self.variables,\n            lambda x: x in self.constants or is_numeric(x) or is_known_constant(x),\n        )\n        self._build()\n\n    def get_evaluation(\n        self, min_val: int = -1, max_val: int = 1, num_samples: int = 100\n    ):\n        \"\"\"\n        Evaluate the nodes with random samples for variables and constants.\n        \"\"\"\n\n        crossings = self._create_crossing(min_val, max_val, num_samples)\n        evaluation = np.zeros((len(crossings), len(self.expr)))\n\n        for i, crossing in enumerate(crossings):\n            eqn_input = dict()\n            k = 0\n            for c in self.constants_unique:\n                if is_numeric(c):\n                    eqn_input[c] = float(c)\n                elif c == \"e\":\n                    eqn_input[c] = 2.71828182846\n                elif c == \"pi\":\n                    eqn_input[c] = 3.14159265359\n                else:\n                    eqn_input[c] = crossing[self.n_variables_unique + k]\n                    k += 1\n            for idx, x in enumerate(self.variables_unique):\n                eqn_input[x] = crossing[idx]\n            evaluation[i, :] = self._evaluate(eqn_input)\n\n        self.evaluation = evaluation\n        return evaluation\n\n    def _evaluate(self, features: Dict):\n        values: List[float] = list()\n\n        if self.root is not None:\n            self._evaluate_node(features, self.root)\n            values = self._get_full_evaluation(self.root)\n\n        return values\n\n    def _evaluate_node(self, features: Dict, node: TreeNode):\n        if node.kind == NodeKind.FUNCTION:\n            if node.left is None:\n                raise Exception(\"Invalid tree: %s\" % self.expr)\n            value = FUNCTIONS[node.attribute](self._evaluate_node(features, node.left))\n\n        elif node.kind == NodeKind.OPERATOR:\n            if node.left is None or node.right is None:\n                raise Exception(\"Invalid tree: %s\" % self.expr)\n            value = OPERATORS[node.attribute](\n                self._evaluate_node(features, node.left),\n                self._evaluate_node(features, node.right),\n            )\n\n        elif node.kind == NodeKind.CONSTANT or node.kind == NodeKind.VARIABLE:\n            value = features[node.attribute]\n        else:\n            raise Exception(\"Invalid attribute %s\" % node.attribute)\n        node.evaluation = value\n        return value\n\n    def _get_full_evaluation(self, node: TreeNode):\n        values = list()\n        values.append(node.evaluation)\n\n        if node.kind == NodeKind.FUNCTION:\n            if node.left is None:\n                raise Exception(\"Invalid tree: %s\" % self.expr)\n            eval_add = self._get_full_evaluation(node.left)\n            for eval_element in eval_add:\n                values.append(eval_element)\n\n        if node.kind == NodeKind.OPERATOR:\n            if node.left is None or node.right is None:\n                raise Exception(\"Invalid tree: %s\" % self.expr)\n            eval_add = self._get_full_evaluation(node.left)\n            for eval_element in eval_add:\n                values.append(eval_element)\n            eval_add = self._get_full_evaluation(node.right)\n            for eval_element in eval_add:\n                values.append(eval_element)\n\n        return values\n\n    def _create_crossing(\n        self, min_val: float = -1, max_val: float = 1, num_samples: int = 100\n    ):\n        crossings = []\n\n        total_unique = self.n_variables_unique + self.n_non_numeric_constants_unique\n\n        for _ in range(num_samples):\n            sample = []\n            for _ in range(total_unique):\n                value = np.random.uniform(min_val, max_val)\n                sample.append(value)\n            crossings.append(sample)\n\n        return np.array(crossings)\n\n    def _build(self):\n        self.structure: List[int] = []\n\n        # make function to get this here\n        self.expr: List[str] = list()\n\n        self.variables: List[str] = list()\n        self.functions: List[str] = list()\n        self.operators: List[str] = list()\n        self.constants: List[str] = list()\n\n        self.evaluation = None\n\n        self._collect_structure(self.structure, 0, self.root)\n\n        self._collect_attributes(\n            lambda node: node.kind == NodeKind.VARIABLE, self.variables, self.root\n        )\n        self._collect_attributes(\n            lambda node: node.kind == NodeKind.FUNCTION, self.functions, self.root\n        )\n        self._collect_attributes(\n            lambda node: node.kind == NodeKind.CONSTANT, self.constants, self.root\n        )\n        self._collect_attributes(\n            lambda node: node.kind == NodeKind.OPERATOR, self.operators, self.root\n        )\n        self._collect_expr(self.expr, self.root)\n\n    def _collect_structure(self, structure=[], level=0, node=None):\n        if node is None:\n            return\n        structure.append(level)\n        self._collect_structure(structure, level + 1, node.left)\n        self._collect_structure(structure, level + 1, node.right)\n        return\n\n    def _collect_expr(self, expression=[], node=None):\n        if node is None:\n            return\n        expression.append(node.attribute)\n        self._collect_expr(expression, node.left)\n        self._collect_expr(expression, node.right)\n\n    def _collect_attributes(\n        self, attribute_identifier: Callable = lambda _: True, attributes=[], node=None\n    ):\n        if node is None:\n            return list()\n        if attribute_identifier(node):\n            attributes.append(node.attribute)\n        if node.left is not None:\n            self._collect_attributes(attribute_identifier, attributes, node.left)\n        if node.right is not None:\n            self._collect_attributes(attribute_identifier, attributes, node.right)\n        return attributes\n\n    def _get_conditionals(self, attribute):\n        functions = {}\n        operators = {}\n        features = {\"constants\": 0, \"variables\": 0}\n\n        def get_child(node):\n            nonlocal functions, operators, features\n            if node is None:\n                return\n            if node.attribute == attribute:\n                if node.kind == NodeKind.FUNCTION or NodeKind.OPERATOR:\n                    if node.left.kind == NodeKind.FUNCTION:\n                        if node.left.attribute in functions.keys():\n                            functions[node.left.attribute] += 1\n                        else:\n                            functions[node.left.attribute] = 1\n                    if node.left.kind == NodeKind.OPERATOR:\n                        if node.left.attribute in operators.keys():\n                            operators[node.left.attribute] += 1\n                        else:\n                            operators[node.left.attribute] = 1\n                    if node.left.kind == NodeKind.CONSTANT:\n                        features[\"constants\"] += 1\n                    if node.left.kind == NodeKind.VARIABLE:\n                        features[\"variables\"] += 1\n                if node.kind == NodeKind.OPERATOR:\n                    if node.right.kind == NodeKind.FUNCTION:\n                        if node.right.attribute in functions.keys():\n                            functions[node.right.attribute] += 1\n                        else:\n                            functions[node.right.attribute] = 1\n                    if node.right.kind == NodeKind.OPERATOR:\n                        if node.right.attribute in operators.keys():\n                            operators[node.right.attribute] += 1\n                        else:\n                            operators[node.right.attribute] = 1\n                    if node.right.kind == NodeKind.CONSTANT:\n                        features[\"constants\"] += 1\n                    if node.right.kind == NodeKind.VARIABLE:\n                        features[\"variables\"] += 1\n            get_child(node.left)\n            get_child(node.right)\n\n        get_child(self.root)\n\n        return functions, operators, features\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.info","title":"<code>info</code>  <code>property</code>","text":"<p>Get al information as dictionary</p>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__","title":"<code>__init__(node)</code>","text":"<p>Initializes a tree from a TreeNode</p> <p>Examples:</p>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__--we-can-inititlize-from-a-single-node","title":"We can inititlize from a single node","text":"<pre><code>&gt;&gt;&gt; node_root = TreeNode(kind=NodeKind.VARIABLE, attribute=\"x\")\n&gt;&gt;&gt; equation_tree = EquationTree(node_root)\n&gt;&gt;&gt; equation_tree.expr\n['x']\n&gt;&gt;&gt; equation_tree.structure\n[0]\n&gt;&gt;&gt; equation_tree.variables\n['x']\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__--or-from-a-node-with-children","title":"Or from a node with children","text":"<pre><code>&gt;&gt;&gt; node_left = TreeNode(kind=NodeKind.VARIABLE, attribute=\"x\")\n&gt;&gt;&gt; node_right = TreeNode(kind=NodeKind.CONSTANT, attribute=\"c\")\n&gt;&gt;&gt; node_root = TreeNode(kind=NodeKind.OPERATOR, attribute=\"+\",                             left=node_left, right=node_right)\n&gt;&gt;&gt; equation_tree = EquationTree(node_root)\n&gt;&gt;&gt; equation_tree.expr\n['+', 'x', 'c']\n&gt;&gt;&gt; equation_tree.structure\n[0, 1, 1]\n&gt;&gt;&gt; equation_tree.variables\n['x']\n&gt;&gt;&gt; equation_tree.constants\n['c']\n&gt;&gt;&gt; equation_tree.operators\n['+']\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__--we-can-first-sample-a-node-and-children-and-initialize-from-that","title":"We can first sample a node and children and initialize from that","text":"<pre><code>&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; max_depth = 12\n&gt;&gt;&gt; structure_priors = {'[0, 1, 2, 1, 2, 3]': .5, '[0, 1, 2, 2, 1, 2, 3]': .5}\n&gt;&gt;&gt; feature_priors = {\"x_1\": 0.5, \"c_1\": 0.5}\n&gt;&gt;&gt; function_priors = {\"sin\": 0.5, \"cos\": 0.5}\n&gt;&gt;&gt; operator_priors = {\"+\": 0.5, \"-\": 0.5}\n&gt;&gt;&gt; node_root = sample_tree(feature_priors, function_priors,\n...     operator_priors, structure_priors)\n&gt;&gt;&gt; equation_tree = EquationTree(node_root)\n&gt;&gt;&gt; equation_tree.expr\n['-', 'cos', 'c_1', 'sin', 'sin', 'x_1']\n&gt;&gt;&gt; equation_tree.structure\n[0, 1, 2, 1, 2, 3]\n&gt;&gt;&gt; equation_tree.variables\n['x_1']\n&gt;&gt;&gt; equation_tree.n_variables\n1\n&gt;&gt;&gt; equation_tree.n_variables_unique\n1\n&gt;&gt;&gt; equation_tree.constants\n['c_1']\n&gt;&gt;&gt; equation_tree.n_constants\n1\n&gt;&gt;&gt; equation_tree.n_constants_unique\n1\n&gt;&gt;&gt; equation_tree.n_leafs\n2\n&gt;&gt;&gt; equation_tree.operators\n['-']\n&gt;&gt;&gt; equation_tree.functions\n['cos', 'sin', 'sin']\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__--first-we-create-test-functions-that-test-weather-an-attribute-is-a-variable","title":"First we create test functions that test weather an attribute is a variable,","text":""},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__--a-constant-a-function-or-an-operater","title":"a constant, a function, or an operater","text":"<pre><code>&gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y', 'z']\n&gt;&gt;&gt; is_constant = lambda x : x in ['0', '1', '2']\n&gt;&gt;&gt; is_function = lambda x : x in ['sin', 'cos']\n&gt;&gt;&gt; is_operator = lambda x: x in ['+', '-', '*', '/']\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__--here-we-use-the-prefix-notation","title":"here we use the prefix notation","text":"<pre><code>&gt;&gt;&gt; prefix_notation = ['+', '-', 'x', '1', '*', 'sin', 'y', 'cos', 'z']\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__--then-we-create-the-node-root","title":"then we create the node root","text":"<pre><code>&gt;&gt;&gt; node_root = node_from_prefix(\n...     prefix_notation=prefix_notation,\n...     variable_test=is_variable,\n...     constant_test=is_constant,\n...     function_test=is_function,\n...     operator_test=is_operator\n...     )\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__--and-initialize-the-tree","title":"and initialize the tree","text":"<pre><code>&gt;&gt;&gt; equation_tree = EquationTree(node_root)\n&gt;&gt;&gt; equation_tree.structure\n[0, 1, 2, 2, 1, 2, 3, 2, 3]\n&gt;&gt;&gt; equation_tree.variables\n['x', 'y', 'z']\n&gt;&gt;&gt; equation_tree.constants\n['1']\n&gt;&gt;&gt; equation_tree.operators\n['+', '-', '*']\n&gt;&gt;&gt; equation_tree.functions\n['sin', 'cos']\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.__init__--the-tree-expression-is-the-same-as-the-prefix-notation","title":"The tree expression is the same as the prefix notation","text":"<pre><code>&gt;&gt;&gt; equation_tree.expr == prefix_notation\nTrue\n</code></pre> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def __init__(self, node: TreeNode):\n    \"\"\"\n    Initializes a tree from a TreeNode\n\n    Examples:\n        # We can inititlize from a single node\n        &gt;&gt;&gt; node_root = TreeNode(kind=NodeKind.VARIABLE, attribute=\"x\")\n        &gt;&gt;&gt; equation_tree = EquationTree(node_root)\n        &gt;&gt;&gt; equation_tree.expr\n        ['x']\n        &gt;&gt;&gt; equation_tree.structure\n        [0]\n        &gt;&gt;&gt; equation_tree.variables\n        ['x']\n\n        # Or from a node with children\n        &gt;&gt;&gt; node_left = TreeNode(kind=NodeKind.VARIABLE, attribute=\"x\")\n        &gt;&gt;&gt; node_right = TreeNode(kind=NodeKind.CONSTANT, attribute=\"c\")\n        &gt;&gt;&gt; node_root = TreeNode(kind=NodeKind.OPERATOR, attribute=\"+\", \\\n                        left=node_left, right=node_right)\n        &gt;&gt;&gt; equation_tree = EquationTree(node_root)\n        &gt;&gt;&gt; equation_tree.expr\n        ['+', 'x', 'c']\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 1]\n        &gt;&gt;&gt; equation_tree.variables\n        ['x']\n        &gt;&gt;&gt; equation_tree.constants\n        ['c']\n        &gt;&gt;&gt; equation_tree.operators\n        ['+']\n\n        # We can first sample a node and children and initialize from that\n        &gt;&gt;&gt; np.random.seed(42)\n        &gt;&gt;&gt; max_depth = 12\n        &gt;&gt;&gt; structure_priors = {'[0, 1, 2, 1, 2, 3]': .5, '[0, 1, 2, 2, 1, 2, 3]': .5}\n        &gt;&gt;&gt; feature_priors = {\"x_1\": 0.5, \"c_1\": 0.5}\n        &gt;&gt;&gt; function_priors = {\"sin\": 0.5, \"cos\": 0.5}\n        &gt;&gt;&gt; operator_priors = {\"+\": 0.5, \"-\": 0.5}\n        &gt;&gt;&gt; node_root = sample_tree(feature_priors, function_priors,\n        ...     operator_priors, structure_priors)\n        &gt;&gt;&gt; equation_tree = EquationTree(node_root)\n        &gt;&gt;&gt; equation_tree.expr\n        ['-', 'cos', 'c_1', 'sin', 'sin', 'x_1']\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 2, 1, 2, 3]\n        &gt;&gt;&gt; equation_tree.variables\n        ['x_1']\n        &gt;&gt;&gt; equation_tree.n_variables\n        1\n        &gt;&gt;&gt; equation_tree.n_variables_unique\n        1\n        &gt;&gt;&gt; equation_tree.constants\n        ['c_1']\n        &gt;&gt;&gt; equation_tree.n_constants\n        1\n        &gt;&gt;&gt; equation_tree.n_constants_unique\n        1\n        &gt;&gt;&gt; equation_tree.n_leafs\n        2\n        &gt;&gt;&gt; equation_tree.operators\n        ['-']\n        &gt;&gt;&gt; equation_tree.functions\n        ['cos', 'sin', 'sin']\n\n        # First we create test functions that test weather an attribute is a variable,\n        # a constant, a function, or an operater\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y', 'z']\n        &gt;&gt;&gt; is_constant = lambda x : x in ['0', '1', '2']\n        &gt;&gt;&gt; is_function = lambda x : x in ['sin', 'cos']\n        &gt;&gt;&gt; is_operator = lambda x: x in ['+', '-', '*', '/']\n\n        # here we use the prefix notation\n        &gt;&gt;&gt; prefix_notation = ['+', '-', 'x', '1', '*', 'sin', 'y', 'cos', 'z']\n\n        # then we create the node root\n        &gt;&gt;&gt; node_root = node_from_prefix(\n        ...     prefix_notation=prefix_notation,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant,\n        ...     function_test=is_function,\n        ...     operator_test=is_operator\n        ...     )\n\n        # and initialize the tree\n        &gt;&gt;&gt; equation_tree = EquationTree(node_root)\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 2, 2, 1, 2, 3, 2, 3]\n        &gt;&gt;&gt; equation_tree.variables\n        ['x', 'y', 'z']\n        &gt;&gt;&gt; equation_tree.constants\n        ['1']\n        &gt;&gt;&gt; equation_tree.operators\n        ['+', '-', '*']\n        &gt;&gt;&gt; equation_tree.functions\n        ['sin', 'cos']\n\n        # The tree expression is the same as the prefix notation\n        &gt;&gt;&gt; equation_tree.expr == prefix_notation\n        True\n    \"\"\"\n\n    self.root: Union[TreeNode, None] = node\n\n    self.structure: List[int] = []\n\n    self.expr: List[str] = list()\n\n    self.variables: List[str] = list()\n    self.functions: List[str] = list()\n    self.operators: List[str] = list()\n    self.constants: List[str] = list()\n\n    self.evaluation = None\n\n    self._build()\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.check_possible","title":"<code>check_possible(feature_priors, function_priors, operator_priors, structure_priors)</code>","text":"<p>Check weather a tree is a possible tree given the priors Attention:     If no prior is given, interpreted as all possibilities are allowed</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def check_possible(\n    self,\n    feature_priors: Dict,\n    function_priors: Dict,\n    operator_priors: Dict,\n    structure_priors: Dict,\n):\n    \"\"\"\n    Check weather a tree is a possible tree given the priors\n    Attention:\n        If no prior is given, interpreted as all possibilities are allowed\n    \"\"\"\n    if feature_priors != {}:\n        for c in self.constants:\n            if c not in feature_priors.keys() or feature_priors[c] &lt;= 0:\n                return False\n        for v in self.variables:\n            if v not in feature_priors.keys() or feature_priors[v] &lt;= 0:\n                return False\n    if function_priors != {}:\n        for fun in self.functions:\n            if fun not in function_priors.keys() or function_priors[fun] &lt;= 0:\n                return False\n    if operator_priors != {}:\n        for op in self.operators:\n            if op not in operator_priors.keys() or operator_priors[op] &lt;= 0:\n                return False\n    if structure_priors != {}:\n        if (\n            str(self.structure) not in structure_priors.keys()\n            or structure_priors[str(self.structure)] &lt;= 0\n        ):\n            return False\n    return True\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.check_validity","title":"<code>check_validity(zero_representations=['0'], log_representations=['log', 'Log'], division_representations=['/', ':'], verbose=False)</code>","text":"Check if the tree is valid <ul> <li>Check if log(0) or x / 0 exists</li> <li>Check if function(constant) or operator(constant_1, constant_2) exists         -&gt; unnecessary complexity</li> <li>Check if each function has exactly one child</li> <li>Check if each operator has exactly two children</li> </ul> <p>Parameters:</p> Name Type Description Default <code>zero_representations</code> <p>A list of attributes that represent zero</p> <code>['0']</code> <code>log_representations</code> <p>A list of attributes that represent log</p> <code>['log', 'Log']</code> <code>division_representations</code> <p>A list of attributes that represent division</p> <code>['/', ':']</code> <code>verbose</code> <p>If set true, print out the reason for the invalid tree</p> <code>False</code> Example <p>is_variable = lambda x : x == 'x' is_constant = lambda x : x == 'c' or x == '0' is_operator = lambda x : x == '/' equation_tree = EquationTree.from_prefix( ...     ['/', 'x', '0'], ...     variable_test=is_variable, ...     constant_test=is_constant, ...     operator_test=is_operator, ... ) equation_tree.check_validity() False equation_tree.check_validity(verbose=True) division by 0 is not allowed. False equation_tree = EquationTree.from_prefix( ...     ['/', 'x', 'c'], ...     variable_test=is_variable, ...     constant_test=is_constant, ...     operator_test=is_operator, ... ) equation_tree.check_validity() True</p> <p>equation_tree = EquationTree.from_prefix( ...     ['/', '0', 'c'], ...     variable_test=is_variable, ...     constant_test=is_constant, ...     operator_test=is_operator, ... ) equation_tree.check_validity(verbose=True) 0 and c are constants applied to the operator / False</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def check_validity(\n    self,\n    zero_representations=[\"0\"],\n    log_representations=[\"log\", \"Log\"],\n    division_representations=[\"/\", \":\"],\n    verbose=False,\n):\n    \"\"\"\n    Check if the tree is valid:\n        - Check if log(0) or x / 0 exists\n        - Check if function(constant) or operator(constant_1, constant_2) exists\n                -&gt; unnecessary complexity\n        - Check if each function has exactly one child\n        - Check if each operator has exactly two children\n\n    Args:\n        zero_representations: A list of attributes that represent zero\n        log_representations: A list of attributes that represent log\n        division_representations: A list of attributes that represent division\n        verbose: If set true, print out the reason for the invalid tree\n\n    Example:\n        &gt;&gt;&gt; is_variable = lambda x : x == 'x'\n        &gt;&gt;&gt; is_constant = lambda x : x == 'c' or x == '0'\n        &gt;&gt;&gt; is_operator = lambda x : x == '/'\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n        ...     ['/', 'x', '0'],\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant,\n        ...     operator_test=is_operator,\n        ... )\n        &gt;&gt;&gt; equation_tree.check_validity()\n        False\n        &gt;&gt;&gt; equation_tree.check_validity(verbose=True)\n        division by 0 is not allowed.\n        False\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n        ...     ['/', 'x', 'c'],\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant,\n        ...     operator_test=is_operator,\n        ... )\n        &gt;&gt;&gt; equation_tree.check_validity()\n        True\n\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n        ...     ['/', '0', 'c'],\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant,\n        ...     operator_test=is_operator,\n        ... )\n        &gt;&gt;&gt; equation_tree.check_validity(verbose=True)\n        0 and c are constants applied to the operator /\n        False\n    \"\"\"\n    return self.root.check_validity(\n        zero_representations, log_representations, division_representations, verbose\n    )\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.evaluate","title":"<code>evaluate(variables)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = sympify('x_a + 3 * y')\n&gt;&gt;&gt; is_operator = lambda x : x in ['+', '*']\n&gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['y']\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     expr,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n... )\n&gt;&gt;&gt; equation_tree.sympy_expr\nx_1 + 3*x_2\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.evaluate--we-can-use-dicts","title":"We can use dicts:","text":"<pre><code>&gt;&gt;&gt; equation_tree.evaluate({'x_1': np.array([2, 3]), 'x_2': np.array([1, 1])})\narray([5, 6])\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.evaluate--or-pandas-dataframe","title":"Or pandas dataframe:","text":"<pre><code>&gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': np.array([2, 3]), 'x_2': np.array([1, 1])})\n&gt;&gt;&gt; dataFrame\n   x_1  x_2\n0    2    1\n1    3    1\n&gt;&gt;&gt; equation_tree.evaluate(dataFrame)\narray([5, 6])\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.evaluate--or-pandas-dataframe","title":"Or pandas dataframe:","text":"<pre><code>&gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [2, 3], 'x_2': [1, 1]})\n&gt;&gt;&gt; dataFrame\n   x_1  x_2\n0    2    1\n1    3    1\n&gt;&gt;&gt; equation_tree.evaluate(dataFrame)\narray([5, 6])\n</code></pre> <pre><code>&gt;&gt;&gt; expr = sympify('min(x_1,x_2)')\n&gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', 'min']\n&gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['x_1', 'x_2']\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     expr,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n... )\n&gt;&gt;&gt; equation_tree.sympy_expr\nMin(x_1, x_2)\n</code></pre> <pre><code>&gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [1, 2, 3, 4], 'x_2': [2, 1, 4, 3]})\n&gt;&gt;&gt; equation_tree.evaluate(dataFrame)\narray([1, 1, 3, 3])\n</code></pre> <pre><code>&gt;&gt;&gt; expr = sympify('max(3, x_1)')\n&gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', 'min', 'max']\n&gt;&gt;&gt; is_function = lambda x : x in ['sqrt', 'log', 'abs']\n&gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['x_1', 'x_2']\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     expr,\n...     function_test=is_function,\n...     operator_test=is_operator,\n...     variable_test=is_variable)\n&gt;&gt;&gt; equation_tree.sympy_expr\nMax(3, x_1)\n&gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [1, 2, 3, 4]})\n&gt;&gt;&gt; equation_tree.evaluate(dataFrame)\narray([3, 3, 3, 4])\n</code></pre> <pre><code>&gt;&gt;&gt; expr = sympify('x_1 + sqrt(x_1)')\n&gt;&gt;&gt; is_operator = lambda x : x in ['+']\n&gt;&gt;&gt; is_function = lambda x: x in ['sqrt']\n&gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['x_1']\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     expr,\n...     operator_test=is_operator,\n...     function_test=is_function,\n...     variable_test=is_variable,\n... )\n&gt;&gt;&gt; equation_tree.sympy_expr\nsqrt(x_1) + x_1\n</code></pre> <pre><code>&gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [4, 9, 16]})\n&gt;&gt;&gt; equation_tree.evaluate(dataFrame)\narray([ 6., 12., 20.])\n</code></pre> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def evaluate(self, variables: Union[dict, pd.DataFrame]):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; expr = sympify('x_a + 3 * y')\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*']\n        &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['y']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     expr,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        x_1 + 3*x_2\n\n        # We can use dicts:\n        &gt;&gt;&gt; equation_tree.evaluate({'x_1': np.array([2, 3]), 'x_2': np.array([1, 1])})\n        array([5, 6])\n\n        # Or pandas dataframe:\n        &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': np.array([2, 3]), 'x_2': np.array([1, 1])})\n        &gt;&gt;&gt; dataFrame\n           x_1  x_2\n        0    2    1\n        1    3    1\n        &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n        array([5, 6])\n\n        # Or pandas dataframe:\n        &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [2, 3], 'x_2': [1, 1]})\n        &gt;&gt;&gt; dataFrame\n           x_1  x_2\n        0    2    1\n        1    3    1\n        &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n        array([5, 6])\n\n        &gt;&gt;&gt; expr = sympify('min(x_1,x_2)')\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', 'min']\n        &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['x_1', 'x_2']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     expr,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        Min(x_1, x_2)\n\n        &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [1, 2, 3, 4], 'x_2': [2, 1, 4, 3]})\n        &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n        array([1, 1, 3, 3])\n\n        &gt;&gt;&gt; expr = sympify('max(3, x_1)')\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', 'min', 'max']\n        &gt;&gt;&gt; is_function = lambda x : x in ['sqrt', 'log', 'abs']\n        &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['x_1', 'x_2']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     expr,\n        ...     function_test=is_function,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable)\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        Max(3, x_1)\n        &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [1, 2, 3, 4]})\n        &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n        array([3, 3, 3, 4])\n\n        &gt;&gt;&gt; expr = sympify('x_1 + sqrt(x_1)')\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+']\n        &gt;&gt;&gt; is_function = lambda x: x in ['sqrt']\n        &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['x_1']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     expr,\n        ...     operator_test=is_operator,\n        ...     function_test=is_function,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        sqrt(x_1) + x_1\n\n        &gt;&gt;&gt; dataFrame = pd.DataFrame({'x_1': [4, 9, 16]})\n        &gt;&gt;&gt; equation_tree.evaluate(dataFrame)\n        array([ 6., 12., 20.])\n    \"\"\"\n\n    df = pd.DataFrame(variables)\n    symbol_list = list(self.sympy_expr.free_symbols)\n\n    if set(list(df.columns)).issubset(set(symbol_list)):\n        raise Exception(\n            f\"Variables in expression {self.sympy_expr} \"\n            f\"do not match the given ones: {df.columns}\"\n        )\n\n    symbol_names = [str(s) for s in symbol_list]\n\n    f = sympy.lambdify(symbol_list, self.sympy_expr, \"numpy\")\n    try:\n        res = np.array(f(*[df[name] for name in symbol_names]))\n    except ValueError:  # Workaround till sympy gets updated\n        lst = [df[name] for name in symbol_names]\n        res = []\n        for i in range(len(lst[0])):\n            args = []\n            for j in range(len(lst)):\n                args.append(lst[j].iloc[i])\n            res.append(f(*args))\n    return np.array(res)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.export_to_srbench","title":"<code>export_to_srbench(folder, data_file_name=None, num_samples=1000, name_target='y', ranges=None, default_range=10, random_state=None)</code>","text":"<p>Creates a folder and adds data and metadata to the folder that can be used with sr bench: https://cavalab.org/srbench/ Args:     folder: Name of the folder     data_file_name: Name of the datafile (if none same as folder name)     num_samples: Number of samples     name_target: Name of the tartget     ranges: A dictionary with the ranges for the variables in form of a dict     default_range: Default range to fall back to if no range for a         specific variable is given     random_state: The random seed to be used</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def export_to_srbench(\n    self,\n    folder: str,\n    data_file_name: Optional[str] = None,\n    num_samples: int = 1000,\n    name_target: str = \"y\",\n    ranges: Optional[Dict] = None,\n    default_range: float = 10,\n    random_state: Optional[int] = None,\n):\n    \"\"\"\n    Creates a folder and adds data and metadata to the folder that can be used with sr bench:\n    https://cavalab.org/srbench/\n    Args:\n        folder: Name of the folder\n        data_file_name: Name of the datafile (if none same as folder name)\n        num_samples: Number of samples\n        name_target: Name of the tartget\n        ranges: A dictionary with the ranges for the variables in form of a dict\n        default_range: Default range to fall back to if no range for a\n            specific variable is given\n        random_state: The random seed to be used\n    \"\"\"\n    if data_file_name is None:\n        data_file_name = folder\n    os.mkdir(folder)\n    path_data = f\"{folder}/{data_file_name}.tsv.gz\"\n    path_meta = f\"{folder}/metadata.yaml\"\n    self.save_samples_srbench(\n        path_data, num_samples, ranges, default_range, random_state\n    )\n    self.save_meta_srbench(path_meta, \"data\", name_target)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prefix","title":"<code>from_prefix(prefix_notation, function_test=lambda : False, operator_test=lambda : False, variable_test=lambda : False, constant_test=lambda : False)</code>  <code>classmethod</code>","text":"<p>Instantiate a tree from prefix notation</p> <p>Parameters:</p> Name Type Description Default <code>prefix_notation</code> <code>List[str]</code> <p>The equation in prefix notation</p> required <code>function_test</code> <code>Callable</code> <p>A function that tests if the attribute is a function</p> <code>lambda : False</code> <code>operator_test</code> <code>Callable</code> <p>A function that tests if the attribute is an operator</p> <code>lambda : False</code> <code>variable_test</code> <code>Callable</code> <p>A function that tests if the attribute is a variable</p> <code>lambda : False</code> <code>constant_test</code> <code>Callable</code> <p>A function that tests if the attribute is a constant</p> <code>lambda : False</code> Example <p>is_variable = lambda x : x in ['x', 'y', 'z'] is_constant = lambda x : x in ['0', '1', '2'] is_function = lambda x : x in ['sin', 'cos'] is_operator = lambda x: x in ['+', '-', '', '/'] prefix = ['+', '-', 'x', '1', '', 'sin', 'y', 'cos', 'z']</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>@classmethod\ndef from_prefix(\n    cls,\n    prefix_notation: List[str],\n    function_test: Callable = lambda _: False,\n    operator_test: Callable = lambda _: False,\n    variable_test: Callable = lambda _: False,\n    constant_test: Callable = lambda _: False,\n):\n    \"\"\"\n    Instantiate a tree from prefix notation\n\n    Args:\n        prefix_notation: The equation in prefix notation\n        function_test: A function that tests if the attribute is a function\n        operator_test: A function that tests if the attribute is an operator\n        variable_test: A function that tests if the attribute is a variable\n        constant_test: A function that tests if the attribute is a constant\n\n    Example:\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y', 'z']\n        &gt;&gt;&gt; is_constant = lambda x : x in ['0', '1', '2']\n        &gt;&gt;&gt; is_function = lambda x : x in ['sin', 'cos']\n        &gt;&gt;&gt; is_operator = lambda x: x in ['+', '-', '*', '/']\n        &gt;&gt;&gt; prefix = ['+', '-', 'x', '1', '*', 'sin', 'y', 'cos', 'z']\n\n        # then we create the node root\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n        ...     prefix_notation=prefix,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant,\n        ...     function_test=is_function,\n        ...     operator_test=is_operator\n        ...     )\n\n        # and initialize the tree\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 2, 2, 1, 2, 3, 2, 3]\n        &gt;&gt;&gt; equation_tree.variables\n        ['x', 'y', 'z']\n        &gt;&gt;&gt; equation_tree.constants\n        ['1']\n        &gt;&gt;&gt; equation_tree.operators\n        ['+', '-', '*']\n        &gt;&gt;&gt; equation_tree.functions\n        ['sin', 'cos']\n\n        # The tree expression is the same as the prefix notation\n        &gt;&gt;&gt; equation_tree.expr == prefix\n        True\n\n\n    \"\"\"\n    root = node_from_prefix(\n        prefix_notation, function_test, operator_test, variable_test, constant_test\n    )\n    return cls(root)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prefix--then-we-create-the-node-root","title":"then we create the node root","text":"<p>equation_tree = EquationTree.from_prefix( ...     prefix_notation=prefix, ...     variable_test=is_variable, ...     constant_test=is_constant, ...     function_test=is_function, ...     operator_test=is_operator ...     )</p>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prefix--and-initialize-the-tree","title":"and initialize the tree","text":"<p>equation_tree.structure [0, 1, 2, 2, 1, 2, 3, 2, 3] equation_tree.variables ['x', 'y', 'z'] equation_tree.constants ['1'] equation_tree.operators ['+', '-', '*'] equation_tree.functions ['sin', 'cos']</p>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prefix--the-tree-expression-is-the-same-as-the-prefix-notation","title":"The tree expression is the same as the prefix notation","text":"<p>equation_tree.expr == prefix True</p>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prior","title":"<code>from_prior(prior, max_variables_unique)</code>  <code>classmethod</code>","text":"<p>Initiate a tree from a prior</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Dict</code> <p>The priors in dictionary form</p> required <code>max_variables_unique</code> <code>int</code> <p>The maximum number of unique variables (a tree can have less then this number)</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; np.random.seed(42)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prior--we-can-set-priors-for-features-functions-operators","title":"We can set priors for features, functions, operators","text":""},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prior--and-also-conditionals-based-the-parent","title":"and also conditionals based the parent","text":"<pre><code>&gt;&gt;&gt; p = {\n...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n...     'features': {'constants': .2, 'variables': .8},\n...     'functions': {'sin': .5, 'cos': .5},\n...     'operators': {'+': 1., '-': .0},\n...     'function_conditionals': {\n...                             'sin': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'sin': 0., 'cos': 1.},\n...                                 'operators': {'+': 0., '-': 1.}\n...                             },\n...                             'cos': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'cos': 1., 'sin': 0.},\n...                                 'operators': {'+': 0., '-': 1.}\n...                             }\n...                         },\n...     'operator_conditionals': {\n...                             '+': {\n...                                 'features': {'constants': .5, 'variables': .5},\n...                                 'functions': {'sin': 1., 'cos': 0.},\n...                                 'operators': {'+': 1., '-': 0.}\n...                             },\n...                             '-': {\n...                                 'features': {'constants': .3, 'variables': .7},\n...                                 'functions': {'cos': .5, 'sin': .5},\n...                                 'operators': {'+': .9, '-': .1}\n...                             }\n...                         },\n... }\n&gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n&gt;&gt;&gt; equation_tree.structure\n[0, 1, 2]\n&gt;&gt;&gt; equation_tree.expr\n['cos', 'cos', 'x_1']\n&gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n&gt;&gt;&gt; equation_tree.structure\n[0, 1, 2]\n&gt;&gt;&gt; equation_tree.expr\n['sin', 'cos', 'x_1']\n&gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n&gt;&gt;&gt; equation_tree.structure\n[0, 1, 1]\n&gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n&gt;&gt;&gt; equation_tree.structure\n[0, 1, 2, 3, 2, 3, 1]\n&gt;&gt;&gt; equation_tree.expr\n['+', '+', 'sin', 'x_1', 'sin', 'x_2', 'x_2']\n&gt;&gt;&gt; equation_tree.sympy_expr\nx_2 + sin(x_1) + sin(x_2)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prior--without-conditionals-the-unconditioned-priors-are-the-fallback-option","title":"Without conditionals, the unconditioned priors are the fallback option","text":"<pre><code>&gt;&gt;&gt; p = {\n...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n...     'features': {'constants': .2, 'variables': .8},\n...     'functions': {'sin': .5, 'cos': .5},\n...     'operators': {'+': .5, '-': .5},\n... }\n&gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n&gt;&gt;&gt; equation_tree.structure\n[0, 1, 2, 3, 2, 3, 1]\n&gt;&gt;&gt; equation_tree.expr\n['+', '-', 'cos', 'c_1', 'cos', 'c_2', 'c_3']\n&gt;&gt;&gt; equation_tree.sympy_expr\nc_3 + cos(c_1) - cos(c_2)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prior--note-this-would-be-discarded-in-a-future-step-as-unnecesarry-complex","title":"Note: this would be discarded in a future step as unnecesarry complex","text":"Source code in <code>src/equation_tree/tree.py</code> <pre><code>@classmethod\ndef from_prior(cls, prior: Dict, max_variables_unique: int):\n    \"\"\"\n    Initiate a tree from a prior\n\n    Args:\n        prior: The priors in dictionary form\n        max_variables_unique: The maximum number of unique variables (a tree can have less then\n            this number)\n\n    Examples:\n        &gt;&gt;&gt; np.random.seed(42)\n\n        # We can set priors for features, functions, operators\n        # and also conditionals based the parent\n        &gt;&gt;&gt; p = {\n        ...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n        ...     'features': {'constants': .2, 'variables': .8},\n        ...     'functions': {'sin': .5, 'cos': .5},\n        ...     'operators': {'+': 1., '-': .0},\n        ...     'function_conditionals': {\n        ...                             'sin': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'sin': 0., 'cos': 1.},\n        ...                                 'operators': {'+': 0., '-': 1.}\n        ...                             },\n        ...                             'cos': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'cos': 1., 'sin': 0.},\n        ...                                 'operators': {'+': 0., '-': 1.}\n        ...                             }\n        ...                         },\n        ...     'operator_conditionals': {\n        ...                             '+': {\n        ...                                 'features': {'constants': .5, 'variables': .5},\n        ...                                 'functions': {'sin': 1., 'cos': 0.},\n        ...                                 'operators': {'+': 1., '-': 0.}\n        ...                             },\n        ...                             '-': {\n        ...                                 'features': {'constants': .3, 'variables': .7},\n        ...                                 'functions': {'cos': .5, 'sin': .5},\n        ...                                 'operators': {'+': .9, '-': .1}\n        ...                             }\n        ...                         },\n        ... }\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 2]\n        &gt;&gt;&gt; equation_tree.expr\n        ['cos', 'cos', 'x_1']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 2]\n        &gt;&gt;&gt; equation_tree.expr\n        ['sin', 'cos', 'x_1']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 1]\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 2, 3, 2, 3, 1]\n        &gt;&gt;&gt; equation_tree.expr\n        ['+', '+', 'sin', 'x_1', 'sin', 'x_2', 'x_2']\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        x_2 + sin(x_1) + sin(x_2)\n\n        # Without conditionals, the unconditioned priors are the fallback option\n        &gt;&gt;&gt; p = {\n        ...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n        ...     'features': {'constants': .2, 'variables': .8},\n        ...     'functions': {'sin': .5, 'cos': .5},\n        ...     'operators': {'+': .5, '-': .5},\n        ... }\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prior(p, 3)\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 2, 3, 2, 3, 1]\n        &gt;&gt;&gt; equation_tree.expr\n        ['+', '-', 'cos', 'c_1', 'cos', 'c_2', 'c_3']\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        c_3 + cos(c_1) - cos(c_2)\n\n        # Note: this would be discarded in a future step as unnecesarry complex\n    \"\"\"\n    root = sample_tree_full(prior, max_variables_unique)\n    return cls(root)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_prior_fast","title":"<code>from_prior_fast(prior, tree_depth, max_variables_unique)</code>  <code>classmethod</code>","text":"<p>Initiate a tree from a prior with fast sampling Attention: structure prior is not supported</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Dict</code> <p>The priors in dictionary form (structure priors are not needed)</p> required <code>tree_depth</code> <p>depth of the tree</p> required <code>max_variables_unique</code> <code>int</code> <p>The maximum number of unique variables (a tree can have less then this number)</p> required Source code in <code>src/equation_tree/tree.py</code> <pre><code>@classmethod\ndef from_prior_fast(cls, prior: Dict, tree_depth, max_variables_unique: int):\n    \"\"\"\n    Initiate a tree from a prior with fast sampling\n    Attention: structure prior is not supported\n\n    Args:\n        prior: The priors in dictionary form (structure priors are not needed)\n        tree_depth: depth of the tree\n        max_variables_unique: The maximum number of unique variables (a tree can have less then\n            this number)\n    \"\"\"\n    root = sample_tree_full_fast(prior, tree_depth, max_variables_unique)\n    return cls(root)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_priors","title":"<code>from_priors(feature_priors={}, function_priors={}, operator_priors={}, structure_priors={})</code>  <code>classmethod</code>","text":"<p>Instantiate a tree from priors</p> <p>Attention     - use standard notation here:   variables should be in form x_{number}                                     constants should be in form c_{number}</p> <p>Parameters:</p> Name Type Description Default <code>max_depth</code> <p>Maximum depth of the tree</p> required <code>feature_priors</code> <p>The priors for the features (variables + constants)</p> <code>{}</code> <code>function_priors</code> <p>The priors for the functions</p> <code>{}</code> <code>operator_priors</code> <p>The priors for the operators</p> <code>{}</code> <code>structure_priors</code> <p>The priors for the tree structures</p> <code>{}</code> Example <p>np.random.seed(42) max_depth = 12 feature_priors = {\"x_1\": 0.5, \"c_1\": 0.5} function_priors = {\"sin\": 0.5, \"cos\": 0.5} operator_priors = {\"+\": 0.5, \"-\": 0.5} structure_priors = {'[0, 1, 2, 3, 4, 5, 5, 2, 3, 4, 4]': 1} equation_tree = EquationTree.from_priors( ...     feature_priors, function_priors, operator_priors, structure_priors) equation_tree.expr ['cos', '-', 'cos', 'sin', '+', 'x_1', 'c_1', 'cos', '-', 'x_1', 'c_1'] equation_tree.structure [0, 1, 2, 3, 4, 5, 5, 2, 3, 4, 4] equation_tree.variables ['x_1', 'x_1'] equation_tree.n_variables 2 equation_tree.n_variables_unique 1 equation_tree.constants ['c_1', 'c_1'] equation_tree.n_constants 2 equation_tree.n_constants_unique 1 equation_tree.n_leafs 4 equation_tree.operators ['-', '+', '-'] equation_tree.functions ['cos', 'cos', 'sin', 'cos']</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>@classmethod\ndef from_priors(\n    cls,\n    feature_priors={},\n    function_priors={},\n    operator_priors={},\n    structure_priors={},\n):\n    \"\"\"\n    Instantiate a tree from priors\n\n    Attention\n        - use standard notation here:   variables should be in form x_{number}\n                                        constants should be in form c_{number}\n\n    Args:\n        max_depth: Maximum depth of the tree\n        feature_priors: The priors for the features (variables + constants)\n        function_priors: The priors for the functions\n        operator_priors: The priors for the operators\n        structure_priors: The priors for the tree structures\n\n    Example:\n        &gt;&gt;&gt; np.random.seed(42)\n        &gt;&gt;&gt; max_depth = 12\n        &gt;&gt;&gt; feature_priors = {\"x_1\": 0.5, \"c_1\": 0.5}\n        &gt;&gt;&gt; function_priors = {\"sin\": 0.5, \"cos\": 0.5}\n        &gt;&gt;&gt; operator_priors = {\"+\": 0.5, \"-\": 0.5}\n        &gt;&gt;&gt; structure_priors = {'[0, 1, 2, 3, 4, 5, 5, 2, 3, 4, 4]': 1}\n        &gt;&gt;&gt; equation_tree = EquationTree.from_priors(\n        ...     feature_priors, function_priors, operator_priors, structure_priors)\n        &gt;&gt;&gt; equation_tree.expr\n        ['cos', '-', 'cos', 'sin', '+', 'x_1', 'c_1', 'cos', '-', 'x_1', 'c_1']\n        &gt;&gt;&gt; equation_tree.structure\n        [0, 1, 2, 3, 4, 5, 5, 2, 3, 4, 4]\n        &gt;&gt;&gt; equation_tree.variables\n        ['x_1', 'x_1']\n        &gt;&gt;&gt; equation_tree.n_variables\n        2\n        &gt;&gt;&gt; equation_tree.n_variables_unique\n        1\n        &gt;&gt;&gt; equation_tree.constants\n        ['c_1', 'c_1']\n        &gt;&gt;&gt; equation_tree.n_constants\n        2\n        &gt;&gt;&gt; equation_tree.n_constants_unique\n        1\n        &gt;&gt;&gt; equation_tree.n_leafs\n        4\n        &gt;&gt;&gt; equation_tree.operators\n        ['-', '+', '-']\n        &gt;&gt;&gt; equation_tree.functions\n        ['cos', 'cos', 'sin', 'cos']\n    \"\"\"\n    root = sample_tree(\n        feature_priors,\n        function_priors,\n        operator_priors,\n        structure_priors,\n    )\n    return cls(root)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_sympy","title":"<code>from_sympy(expression, function_test=lambda : False, operator_test=lambda : False, variable_test=lambda : False, constant_test=lambda : False)</code>  <code>classmethod</code>","text":"<p>Instantiate a tree from a sympy function</p> Attention <ul> <li>constant and variable names get standardized</li> <li>unary minus get converted to binary minus</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = sympify('x_a + B * y')\n&gt;&gt;&gt; expr\nB*y + x_a\n&gt;&gt;&gt; is_operator = lambda x : x in ['+', '*']\n&gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['y']\n&gt;&gt;&gt; is_constant = lambda x : x == 'B'\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     expr,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n...     constant_test=is_constant\n... )\n&gt;&gt;&gt; equation_tree.expr\n['+', '*', 'c_1', 'x_2', 'x_1']\n&gt;&gt;&gt; equation_tree.sympy_expr\nc_1*x_2 + x_1\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.from_sympy--numbers-dont-get-standardized-but-are-constants","title":"Numbers don't get standardized but are constants","text":"<pre><code>&gt;&gt;&gt; expr = sympify('x_a + 2 * y')\n&gt;&gt;&gt; expr\nx_a + 2*y\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     expr,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n...     constant_test=is_constant\n... )\n&gt;&gt;&gt; equation_tree.expr\n['+', 'x_1', '*', '2', 'x_2']\n&gt;&gt;&gt; equation_tree.sympy_expr\nx_1 + 2*x_2\n&gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', '**']\n&gt;&gt;&gt; is_variable = lambda x: '_' in x\n&gt;&gt;&gt; is_constant = lambda x: x == 'B'\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     sympify('B*x_1**2'),\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n...     constant_test=is_constant\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; expr = sympify('min(x_1, x_2)')\n&gt;&gt;&gt; expr\nMin(x_1, x_2)\n&gt;&gt;&gt; is_operator = lambda x : x in ['min']\n&gt;&gt;&gt; is_variable = lambda x : x in ['x_1', 'x_2']\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     expr,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n... )\n&gt;&gt;&gt; equation_tree.expr\n['min', 'x_1', 'x_2']\n</code></pre> <pre><code>&gt;&gt;&gt; expr = sympify('x_1**2')\n&gt;&gt;&gt; expr\nx_1**2\n&gt;&gt;&gt; is_operator = lambda x : x in ['*', '/', '**', '+']\n&gt;&gt;&gt; is_variable = lambda x : x in ['x_1']\n&gt;&gt;&gt; is_function = lambda x : x in ['squared']\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     expr,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n...     function_test=is_function\n... )\n&gt;&gt;&gt; equation_tree.expr\n['squared', 'x_1']\n</code></pre> Source code in <code>src/equation_tree/tree.py</code> <pre><code>@classmethod\ndef from_sympy(\n    cls,\n    expression,\n    function_test: Callable = lambda _: False,\n    operator_test: Callable = lambda _: False,\n    variable_test: Callable = lambda _: False,\n    constant_test: Callable = lambda _: False,\n):\n    \"\"\"\n    Instantiate a tree from a sympy function\n\n    Attention:\n        - constant and variable names get standardized\n        - unary minus get converted to binary minus\n\n    Examples:\n        &gt;&gt;&gt; expr = sympify('x_a + B * y')\n        &gt;&gt;&gt; expr\n        B*y + x_a\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*']\n        &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['y']\n        &gt;&gt;&gt; is_constant = lambda x : x == 'B'\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     expr,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant\n        ... )\n        &gt;&gt;&gt; equation_tree.expr\n        ['+', '*', 'c_1', 'x_2', 'x_1']\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        c_1*x_2 + x_1\n\n        # Numbers don't get standardized but are constants\n        &gt;&gt;&gt; expr = sympify('x_a + 2 * y')\n        &gt;&gt;&gt; expr\n        x_a + 2*y\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     expr,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant\n        ... )\n        &gt;&gt;&gt; equation_tree.expr\n        ['+', 'x_1', '*', '2', 'x_2']\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        x_1 + 2*x_2\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', '**']\n        &gt;&gt;&gt; is_variable = lambda x: '_' in x\n        &gt;&gt;&gt; is_constant = lambda x: x == 'B'\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     sympify('B*x_1**2'),\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant\n        ... )\n\n        &gt;&gt;&gt; expr = sympify('min(x_1, x_2)')\n        &gt;&gt;&gt; expr\n        Min(x_1, x_2)\n        &gt;&gt;&gt; is_operator = lambda x : x in ['min']\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x_1', 'x_2']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     expr,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; equation_tree.expr\n        ['min', 'x_1', 'x_2']\n\n        &gt;&gt;&gt; expr = sympify('x_1**2')\n        &gt;&gt;&gt; expr\n        x_1**2\n        &gt;&gt;&gt; is_operator = lambda x : x in ['*', '/', '**', '+']\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x_1']\n        &gt;&gt;&gt; is_function = lambda x : x in ['squared']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     expr,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ...     function_test=is_function\n        ... )\n        &gt;&gt;&gt; equation_tree.expr\n        ['squared', 'x_1']\n\n    \"\"\"\n    standard = standardize_sympy(expression, variable_test, constant_test)\n    standard = unary_minus_to_binary(standard, operator_test)\n    standard = op_const_to_func(standard)\n    prefix = infix_to_prefix(str(standard), function_test, operator_test)\n    root = node_from_prefix(\n        prefix,\n        function_test,\n        operator_test,\n        lambda x: \"x_\" in x,\n        lambda x: \"c_\" in x,\n    )\n    return cls(root)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.get_evaluation","title":"<code>get_evaluation(min_val=-1, max_val=1, num_samples=100)</code>","text":"<p>Evaluate the nodes with random samples for variables and constants.</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def get_evaluation(\n    self, min_val: int = -1, max_val: int = 1, num_samples: int = 100\n):\n    \"\"\"\n    Evaluate the nodes with random samples for variables and constants.\n    \"\"\"\n\n    crossings = self._create_crossing(min_val, max_val, num_samples)\n    evaluation = np.zeros((len(crossings), len(self.expr)))\n\n    for i, crossing in enumerate(crossings):\n        eqn_input = dict()\n        k = 0\n        for c in self.constants_unique:\n            if is_numeric(c):\n                eqn_input[c] = float(c)\n            elif c == \"e\":\n                eqn_input[c] = 2.71828182846\n            elif c == \"pi\":\n                eqn_input[c] = 3.14159265359\n            else:\n                eqn_input[c] = crossing[self.n_variables_unique + k]\n                k += 1\n        for idx, x in enumerate(self.variables_unique):\n            eqn_input[x] = crossing[idx]\n        evaluation[i, :] = self._evaluate(eqn_input)\n\n    self.evaluation = evaluation\n    return evaluation\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.save_samples","title":"<code>save_samples(path, num_samples, ranges=None, default_range=10, dv_name='y', random_state=None, compression='gzip')</code>","text":"<p>Creates a file with samples of ivs and dvs Args:     path: The path were to store the file     num_samples: The number of samples     ranges: A dictionary with the ranges for the variables in form of a dict     default_range: Default range to fall back to if no range for a         specific variable is given     dv_name: The name to give to the observation     random_state: The random seed to be used     compression: Compression method</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def save_samples(\n    self,\n    path,\n    num_samples,\n    ranges: Optional[Dict] = None,\n    default_range: float = 10,\n    dv_name: str = \"y\",\n    random_state: Optional[int] = None,\n    compression: str = \"gzip\",\n):\n    \"\"\"\n    Creates a file with samples of ivs and dvs\n    Args:\n        path: The path were to store the file\n        num_samples: The number of samples\n        ranges: A dictionary with the ranges for the variables in form of a dict\n        default_range: Default range to fall back to if no range for a\n            specific variable is given\n        dv_name: The name to give to the observation\n        random_state: The random seed to be used\n        compression: Compression method\n    \"\"\"\n    if not path.endswith(\"gz\") and compression == \"gzip\":\n        warnings.warn(\n            f\"Compression is gzip but file {path} does not have the ending .gz\"\n        )\n    _ranges = {\n        key: (-default_range, default_range) for key in self.variables_unique\n    }\n    if ranges is not None:\n        for key in ranges.keys():\n            if key in _ranges.keys():\n                _ranges[key] = ranges[key]\n\n    rng = np.random.default_rng(random_state)\n\n    def _get_conditions_once():\n        raw_conditions = {}\n        for key in _ranges.keys():\n            raw_conditions[key] = rng.uniform(*_ranges[key], size=num_samples)\n        return pd.DataFrame(raw_conditions)\n\n    conditions_ = pd.DataFrame(columns=self.variables_unique + [dv_name])\n    i = 0\n    while i &lt; 1_000_000 and len(conditions_.index) &lt; num_samples:\n        _sample = _get_conditions_once()\n        evaluation = self.evaluate(_sample)\n        _sample[dv_name] = evaluation\n        bad_indices = np.where(np.isnan(evaluation) | np.isinf(evaluation))[0]\n        _sample = _sample.drop(bad_indices)\n        conditions_ = pd.concat([conditions_, _sample], ignore_index=True)\n        i += 1\n        if i &gt;= 1_000_000:\n            break\n    conditions_ = conditions_.head(num_samples)\n    conditions_.to_csv(path, compression=compression, index=False, sep=\"\\t\")\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.simplify","title":"<code>simplify(function_test=None, operator_test=None, is_binary_minus_only=True, is_power_caret=True, verbose=False)</code>","text":"<p>Simplify equation if the simplified equation has a shorter prefix Args:     function_test: A function that tests weather an attribute is a function         Attention: simplifying may lead to new functions that were not in the equation             before. If so, add this to the test here.     operator_test: A function that tests weather an attribute is an operator         Attention: simplifying may lead to new operators that were not in the equation             before. If so, add this to the test here.     is_binary_minus_only: Convert all unary minus to binary after simplification     is_power_caret: Represent power as a caret after simplification     verbose: Show messages if simplification results in errors</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_variable = lambda x: 'x_' in x\n&gt;&gt;&gt; is_constant = lambda x: 'c_' in x or is_numeric(x) or is_known_constant(x)\n&gt;&gt;&gt; is_operator = lambda x: x in ['+', '*', '/', '^', '-']\n&gt;&gt;&gt; is_function = lambda x: x.lower() in ['sqrt', 'abs']\n&gt;&gt;&gt; prefix_notation = ['+', 'x_1', 'x_1' ]\n&gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n...     prefix_notation=prefix_notation,\n...     variable_test=is_variable,\n...     constant_test=is_constant,\n...     operator_test=is_operator,\n...     function_test=is_function)\n&gt;&gt;&gt; equation_tree.expr\n['+', 'x_1', 'x_1']\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.simplify--it-takes-care-of-multiplication","title":"it takes care of multiplication:","text":"<pre><code>&gt;&gt;&gt; equation_tree.simplify(function_test=is_function,operator_test=is_operator)\n&gt;&gt;&gt; equation_tree.expr\n['*', '2', 'x_1']\n</code></pre> <pre><code>&gt;&gt;&gt; prefix_notation = ['sqrt', '*', 'x_1', 'x_1']\n&gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n...     prefix_notation=prefix_notation,\n...     variable_test=is_variable,\n...     constant_test=is_constant,\n...     operator_test=is_operator,\n...     function_test=is_function)\n&gt;&gt;&gt; equation_tree.expr\n['sqrt', '*', 'x_1', 'x_1']\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.simplify--it-is-good-practice-to-define-tests-at-the-begining-of-a-script-and-use-them","title":"it is good practice to define tests at the begining of a script and use them","text":""},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.simplify--throughout-the-project","title":"throughout the project","text":"<pre><code>&gt;&gt;&gt; equation_tree.simplify(\n...     operator_test=is_operator,\n...     function_test=is_function\n... )\n&gt;&gt;&gt; equation_tree.expr\n['abs', 'x_1']\n</code></pre> <pre><code>&gt;&gt;&gt; prefix_notation = ['*', '-', 'c_1', 'x_1', '-', 'x_1', 'c_1']\n&gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n...     prefix_notation=prefix_notation,\n...     variable_test=is_variable,\n...     constant_test=is_constant,\n...     operator_test=is_operator,\n...     function_test=is_function)\n&gt;&gt;&gt; equation_tree.expr\n['*', '-', 'c_1', 'x_1', '-', 'x_1', 'c_1']\n</code></pre> <pre><code>&gt;&gt;&gt; equation_tree.sympy_expr\n(-c_1 + x_1)*(c_1 - x_1)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.simplify--it-is-good-practice-to-define-tests-at-the-begining-of-a-script-and-use-them","title":"it is good practice to define tests at the begining of a script and use them","text":""},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.simplify--throughout-the-project","title":"throughout the project","text":"<pre><code>&gt;&gt;&gt; equation_tree.simplify(\n...     operator_test=is_operator,\n...     function_test=is_function\n... )\n&gt;&gt;&gt; equation_tree.sympy_expr\n(-c_1 + x_1)**2\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.simplify--equation_treeexpr","title":"&gt;&gt;&gt; equation_tree.expr","text":""},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.simplify---x_1-c_1-2","title":"['^', '-', 'x_1', 'c_1', '2']","text":"Source code in <code>src/equation_tree/tree.py</code> <pre><code>def simplify(\n    self,\n    function_test: Union[Callable, None] = None,\n    operator_test: Union[Callable, None] = None,\n    is_binary_minus_only: bool = True,\n    is_power_caret: bool = True,\n    verbose: bool = False,\n):\n    \"\"\"\n    Simplify equation if the simplified equation has a shorter prefix\n    Args:\n        function_test: A function that tests weather an attribute is a function\n            Attention: simplifying may lead to new functions that were not in the equation\n                before. If so, add this to the test here.\n        operator_test: A function that tests weather an attribute is an operator\n            Attention: simplifying may lead to new operators that were not in the equation\n                before. If so, add this to the test here.\n        is_binary_minus_only: Convert all unary minus to binary after simplification\n        is_power_caret: Represent power as a caret after simplification\n        verbose: Show messages if simplification results in errors\n\n    Examples:\n        &gt;&gt;&gt; is_variable = lambda x: 'x_' in x\n        &gt;&gt;&gt; is_constant = lambda x: 'c_' in x or is_numeric(x) or is_known_constant(x)\n        &gt;&gt;&gt; is_operator = lambda x: x in ['+', '*', '/', '^', '-']\n        &gt;&gt;&gt; is_function = lambda x: x.lower() in ['sqrt', 'abs']\n        &gt;&gt;&gt; prefix_notation = ['+', 'x_1', 'x_1' ]\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n        ...     prefix_notation=prefix_notation,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant,\n        ...     operator_test=is_operator,\n        ...     function_test=is_function)\n        &gt;&gt;&gt; equation_tree.expr\n        ['+', 'x_1', 'x_1']\n\n        # it takes care of multiplication:\n        &gt;&gt;&gt; equation_tree.simplify(function_test=is_function,operator_test=is_operator)\n        &gt;&gt;&gt; equation_tree.expr\n        ['*', '2', 'x_1']\n\n        &gt;&gt;&gt; prefix_notation = ['sqrt', '*', 'x_1', 'x_1']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n        ...     prefix_notation=prefix_notation,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant,\n        ...     operator_test=is_operator,\n        ...     function_test=is_function)\n        &gt;&gt;&gt; equation_tree.expr\n        ['sqrt', '*', 'x_1', 'x_1']\n\n        # it is good practice to define tests at the begining of a script and use them\n        # throughout the project\n        &gt;&gt;&gt; equation_tree.simplify(\n        ...     operator_test=is_operator,\n        ...     function_test=is_function\n        ... )\n        &gt;&gt;&gt; equation_tree.expr\n        ['abs', 'x_1']\n\n        &gt;&gt;&gt; prefix_notation = ['*', '-', 'c_1', 'x_1', '-', 'x_1', 'c_1']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n        ...     prefix_notation=prefix_notation,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant,\n        ...     operator_test=is_operator,\n        ...     function_test=is_function)\n        &gt;&gt;&gt; equation_tree.expr\n        ['*', '-', 'c_1', 'x_1', '-', 'x_1', 'c_1']\n\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        (-c_1 + x_1)*(c_1 - x_1)\n\n        # it is good practice to define tests at the begining of a script and use them\n        # throughout the project\n        &gt;&gt;&gt; equation_tree.simplify(\n        ...     operator_test=is_operator,\n        ...     function_test=is_function\n        ... )\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        (-c_1 + x_1)**2\n\n        # &gt;&gt;&gt; equation_tree.expr\n        # ['^', '-', 'x_1', 'c_1', '2']\n    \"\"\"\n\n    if function_test is None:\n\n        def function_test(x):\n            return x in self.functions\n\n    else:\n        tmp_f = function_test\n\n        def function_test(x):\n            return tmp_f(x) or x in self.functions\n\n    if operator_test is None:\n\n        def operator_test(x):\n            return x in self.operators\n\n    else:\n        tmp_o = operator_test\n\n        def operator_test(x):\n            return tmp_o(x) or x in self.operators\n\n    class TimeoutError(Exception):\n        pass\n\n    def timeout_handler(signum, frame):\n        raise TimeoutError(\"Function call timed out\")\n\n    signal.signal(signal.SIGALRM, timeout_handler)\n    signal.alarm(SIMPLIFY_TIMEOUT)\n    try:\n        simplified_equation = simplify(self.sympy_expr)\n        signal.alarm(0)\n    except TimeoutError:\n        simplified_equation = self.sympy_expr\n    if not check_functions(simplified_equation, function_test):\n        warnings.warn(\n            f\"{simplified_equation} has functions that are not in function_test type\"\n        )\n        self.root = None\n        self._build()\n        return\n    if (\n        \"I\" in str(simplified_equation)\n        or \"accumbounds\" in str(simplified_equation).lower()\n    ):\n        if verbose:\n            print(f\"Simplify {str(self.sympy_expr)} results in complex values\")\n        self.root = None\n        self._build()\n        return\n    if is_power_caret:\n        simplified_equation = str(simplified_equation).replace(\"**\", \"^\")\n    simplified_equation = simplified_equation.replace(\"re\", \"\")\n    if is_binary_minus_only:\n        simplified_equation = unary_minus_to_binary(\n            simplified_equation, operator_test\n        )\n    simplified_equation = simplified_equation.replace(\" \", \"\")\n\n    prefix = infix_to_prefix(simplified_equation, function_test, operator_test)\n    if verbose:\n        print(\"prefix\", simplified_equation)\n        print(\"prefix tree\", prefix)\n    if \"re\" in prefix:\n        prefix.remove(\"re\")\n    if len(prefix) &gt; len(self.expr):\n        prefix = self.expr\n    if \"zoo\" in prefix or \"oo\" in prefix:\n        if verbose:\n            print(f\"Simplify {str(self.sympy_expr)} results in None\")\n        self.root = None\n        self._build()\n        return\n    self.root = node_from_prefix(\n        prefix,\n        function_test,\n        operator_test,\n        lambda x: x in self.variables,\n        lambda x: x in self.constants or is_numeric(x) or is_known_constant(x),\n    )\n    self._build()\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.standardize","title":"<code>standardize()</code>","text":"<p>Standardize variable and constant names</p> Example <p>is_variable = lambda x : x in ['x', 'y', 'z'] is_constant = lambda x : x in ['0', '1', '2'] is_function = lambda x : x in ['sin', 'cos'] is_operator = lambda x: x in ['+', '-', '', '/'] prefix = ['+', '-', 'x', '1', '', 'sin', 'y', 'cos', 'z']</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def standardize(self):\n    \"\"\"\n    Standardize variable and constant names\n\n    Example:\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y', 'z']\n        &gt;&gt;&gt; is_constant = lambda x : x in ['0', '1', '2']\n        &gt;&gt;&gt; is_function = lambda x : x in ['sin', 'cos']\n        &gt;&gt;&gt; is_operator = lambda x: x in ['+', '-', '*', '/']\n        &gt;&gt;&gt; prefix = ['+', '-', 'x', '1', '*', 'sin', 'y', 'cos', 'z']\n\n        # then we create the node root\n        &gt;&gt;&gt; equation_tree = EquationTree.from_prefix(\n        ...     prefix_notation=prefix,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant,\n        ...     function_test=is_function,\n        ...     operator_test=is_operator\n        ...     )\n\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        x + sin(y)*cos(z) - 1\n\n        &gt;&gt;&gt; equation_tree.standardize()\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        x_1 + sin(x_2)*cos(x_3) - 1\n\n    \"\"\"\n    variable_count = 0\n    constant_count = 0\n    variables = {}\n    constants = {}\n\n    def rec_stand(node):\n        if node is None:\n            return\n        nonlocal variable_count, constant_count\n        nonlocal variables, constants\n        if node.kind == NodeKind.VARIABLE:\n            if node.attribute not in variables.keys():\n                variable_count += 1\n                variables[node.attribute] = f\"x_{variable_count}\"\n            node.attribute = variables[node.attribute]\n        if node.kind == NodeKind.CONSTANT and not is_numeric(node.attribute):\n            if node.attribute not in constants.keys():\n                constant_count += 1\n                constants[node.attribute] = f\"c_{constant_count}\"\n            node.attribute = constants[node.attribute]\n        else:\n            rec_stand(node.left)\n            rec_stand(node.right)\n        return node\n\n    self.root = rec_stand(self.root)\n    self._build()\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.EquationTree.standardize--then-we-create-the-node-root","title":"then we create the node root","text":"<p>equation_tree = EquationTree.from_prefix( ...     prefix_notation=prefix, ...     variable_test=is_variable, ...     constant_test=is_constant, ...     function_test=is_function, ...     operator_test=is_operator ...     )</p> <p>equation_tree.sympy_expr x + sin(y)*cos(z) - 1</p> <p>equation_tree.standardize() equation_tree.sympy_expr x_1 + sin(x_2)*cos(x_3) - 1</p>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.instantiate_constants","title":"<code>instantiate_constants(tree, fct)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = sympify('e ** (- e **( x + y))')\n&gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', '**', '-']\n&gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y']\n&gt;&gt;&gt; is_constant = lambda x : x in ['e']\n&gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n...     expr,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n... )\n&gt;&gt;&gt; equation_tree.sympy_expr\ne**((-e)**(x_1 + x_2))\n&gt;&gt;&gt; instantiated = instantiate_constants(equation_tree, lambda: 2)\n&gt;&gt;&gt; instantiated.sympy_expr\ne**((-e)**(x_1 + x_2))\n&gt;&gt;&gt; expr_2 = sympify('c_1 ** (- e **( x + y))')\n&gt;&gt;&gt; equation_tree_2 = EquationTree.from_sympy(\n...     expr_2,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n... )\n&gt;&gt;&gt; instantiated = instantiate_constants(equation_tree_2, lambda: 2)\n&gt;&gt;&gt; instantiated.sympy_expr\n2**((-e)**(x_1 + x_2))\n</code></pre> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def instantiate_constants(tree, fct: Callable):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; expr = sympify('e ** (- e **( x + y))')\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', '**', '-']\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y']\n        &gt;&gt;&gt; is_constant = lambda x : x in ['e']\n        &gt;&gt;&gt; equation_tree = EquationTree.from_sympy(\n        ...     expr,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; equation_tree.sympy_expr\n        e**((-e)**(x_1 + x_2))\n        &gt;&gt;&gt; instantiated = instantiate_constants(equation_tree, lambda: 2)\n        &gt;&gt;&gt; instantiated.sympy_expr\n        e**((-e)**(x_1 + x_2))\n        &gt;&gt;&gt; expr_2 = sympify('c_1 ** (- e **( x + y))')\n        &gt;&gt;&gt; equation_tree_2 = EquationTree.from_sympy(\n        ...     expr_2,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; instantiated = instantiate_constants(equation_tree_2, lambda: 2)\n        &gt;&gt;&gt; instantiated.sympy_expr\n        2**((-e)**(x_1 + x_2))\n\n\n\n    \"\"\"\n    root = copy.deepcopy(tree.root)\n\n    def _rec_apply(node):\n        if (\n            node.kind == NodeKind.CONSTANT\n            and not is_known_constant(node.attribute)\n            and not is_numeric(node.attribute)\n        ):\n            node.attribute = str(fct())\n        for c in node.children:\n            _rec_apply(c)\n\n    _rec_apply(root)\n    return EquationTree(root)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.normalized_tree_distance","title":"<code>normalized_tree_distance(e_a, e_b)</code>","text":"<p>Normalized edit distance between two trees according to <code>Li, Y., &amp; Chenguang, Z. (2011). A metric normalization of tree edit distance. Frontiers of Computer Science in China, 5, 119-125.</code></p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def normalized_tree_distance(e_a: EquationTree, e_b: EquationTree):\n    \"\"\"\n    Normalized edit distance between two trees according to\n    `Li, Y., &amp; Chenguang, Z. (2011). A metric normalization of tree edit distance.\n    Frontiers of Computer Science in China, 5, 119-125.`\n\n    \"\"\"\n    if e_a.root is None or e_b.root is None:\n        return 1\n    return ned(e_a.root, e_b.root)\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.prediction_distance","title":"<code>prediction_distance(e_a, e_b, X)</code>","text":"<p>Mean squared difference between the prediction of two equations on X</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', '**', '-']\n&gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y']\n&gt;&gt;&gt; expr_1 = sympify('x + y')\n&gt;&gt;&gt; expr_2 = sympify('x')\n&gt;&gt;&gt; et_1 = EquationTree.from_sympy(\n...     expr_1,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n... )\n&gt;&gt;&gt; et_1.sympy_expr\nx_1 + x_2\n&gt;&gt;&gt; et_2 = EquationTree.from_sympy(\n...     expr_2,\n...     operator_test=is_operator,\n...     variable_test=is_variable,\n... )\n&gt;&gt;&gt; et_2.sympy_expr\nx_1\n&gt;&gt;&gt; prediction_distance(et_1, et_2, {'x_1': [1], 'x_2': [1]})\n1.0\n&gt;&gt;&gt; prediction_distance(et_1, et_2, {'x_1': [1, 2, 3], 'x_2': [0, 0, 0]})\n0.0\n&gt;&gt;&gt; prediction_distance(et_1, et_2, {'x_1': [1, 2], 'x_2': [1, 2]})\n2.5\n</code></pre> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def prediction_distance(\n    e_a: EquationTree, e_b: EquationTree, X: Union[dict, pd.DataFrame]\n):\n    \"\"\"\n    Mean squared difference between the prediction of two equations on X\n\n    Examples:\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', '**', '-']\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y']\n        &gt;&gt;&gt; expr_1 = sympify('x + y')\n        &gt;&gt;&gt; expr_2 = sympify('x')\n        &gt;&gt;&gt; et_1 = EquationTree.from_sympy(\n        ...     expr_1,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; et_1.sympy_expr\n        x_1 + x_2\n        &gt;&gt;&gt; et_2 = EquationTree.from_sympy(\n        ...     expr_2,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; et_2.sympy_expr\n        x_1\n        &gt;&gt;&gt; prediction_distance(et_1, et_2, {'x_1': [1], 'x_2': [1]})\n        1.0\n        &gt;&gt;&gt; prediction_distance(et_1, et_2, {'x_1': [1, 2, 3], 'x_2': [0, 0, 0]})\n        0.0\n        &gt;&gt;&gt; prediction_distance(et_1, et_2, {'x_1': [1, 2], 'x_2': [1, 2]})\n        2.5\n\n    \"\"\"\n    predict_a = e_a.evaluate(X)\n    predict_b = e_b.evaluate(X)\n    squared_diff = (predict_a - predict_b) ** 2\n    return squared_diff.mean()\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.symbolic_solution_diff","title":"<code>symbolic_solution_diff(e_a, e_b)</code>","text":"<p>Symbolic solution with difference constant based on <code>La Cava, W. et al (2021). Contemporary symbolic regression methods and their relative performance.</code> Examples:     &gt;&gt;&gt; is_operator = lambda x : x in ['+', '', '*', '-']     &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y']     &gt;&gt;&gt; is_constant = lambda x: is_numeric(x)     &gt;&gt;&gt; expr_1 = sympify('x + .1')     &gt;&gt;&gt; expr_2 = sympify('x')     &gt;&gt;&gt; et_1 = EquationTree.from_sympy(     ...     expr_1,     ...     operator_test=is_operator,     ...     variable_test=is_variable,     ...     constant_test=is_constant     ... )     &gt;&gt;&gt; et_1.sympy_expr     x_1 + 0.1     &gt;&gt;&gt; et_2 = EquationTree.from_sympy(     ...     expr_2,     ...     operator_test=is_operator,     ...     variable_test=is_variable,     ... )     &gt;&gt;&gt; et_2.sympy_expr     x_1     &gt;&gt;&gt; symbolic_solution_diff(et_1, et_2)     0.1</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def symbolic_solution_diff(e_a: EquationTree, e_b: EquationTree):\n    \"\"\"\n    Symbolic solution with difference constant based on\n    `La Cava, W. et al (2021).\n    Contemporary symbolic regression methods and their relative performance.`\n    Examples:\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', '**', '-']\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y']\n        &gt;&gt;&gt; is_constant = lambda x: is_numeric(x)\n        &gt;&gt;&gt; expr_1 = sympify('x + .1')\n        &gt;&gt;&gt; expr_2 = sympify('x')\n        &gt;&gt;&gt; et_1 = EquationTree.from_sympy(\n        ...     expr_1,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant\n        ... )\n        &gt;&gt;&gt; et_1.sympy_expr\n        x_1 + 0.1\n        &gt;&gt;&gt; et_2 = EquationTree.from_sympy(\n        ...     expr_2,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; et_2.sympy_expr\n        x_1\n        &gt;&gt;&gt; symbolic_solution_diff(et_1, et_2)\n        0.1\n    \"\"\"\n    diff = simplify(e_a.sympy_expr - e_b.sympy_expr)\n    if diff.is_constant():\n        return float(diff)\n    else:\n        return np.infty\n</code></pre>"},{"location":"reference/src/equation_tree/tree/#src.equation_tree.tree.symbolic_solution_quot","title":"<code>symbolic_solution_quot(e_a, e_b)</code>","text":"<p>Symbolic solution with quotient constant based on <code>La Cava, W. et al (2021). Contemporary symbolic regression methods and their relative performance.</code> Examples:     &gt;&gt;&gt; is_operator = lambda x : x in ['+', '', '', '-']     &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y']     &gt;&gt;&gt; is_constant = lambda x: is_numeric(x)     &gt;&gt;&gt; expr_1 = sympify('x * .1')     &gt;&gt;&gt; expr_2 = sympify('x')     &gt;&gt;&gt; et_1 = EquationTree.from_sympy(     ...     expr_1,     ...     operator_test=is_operator,     ...     variable_test=is_variable,     ...     constant_test=is_constant     ... )     &gt;&gt;&gt; et_1.sympy_expr     0.1x_1     &gt;&gt;&gt; et_2 = EquationTree.from_sympy(     ...     expr_2,     ...     operator_test=is_operator,     ...     variable_test=is_variable,     ... )     &gt;&gt;&gt; et_2.sympy_expr     x_1     &gt;&gt;&gt; symbolic_solution_quot(et_1, et_2)     0.1</p> Source code in <code>src/equation_tree/tree.py</code> <pre><code>def symbolic_solution_quot(e_a: EquationTree, e_b: EquationTree):\n    \"\"\"\n    Symbolic solution with quotient constant based on\n    `La Cava, W. et al (2021).\n    Contemporary symbolic regression methods and their relative performance.`\n    Examples:\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '*', '**', '-']\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y']\n        &gt;&gt;&gt; is_constant = lambda x: is_numeric(x)\n        &gt;&gt;&gt; expr_1 = sympify('x * .1')\n        &gt;&gt;&gt; expr_2 = sympify('x')\n        &gt;&gt;&gt; et_1 = EquationTree.from_sympy(\n        ...     expr_1,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ...     constant_test=is_constant\n        ... )\n        &gt;&gt;&gt; et_1.sympy_expr\n        0.1*x_1\n        &gt;&gt;&gt; et_2 = EquationTree.from_sympy(\n        ...     expr_2,\n        ...     operator_test=is_operator,\n        ...     variable_test=is_variable,\n        ... )\n        &gt;&gt;&gt; et_2.sympy_expr\n        x_1\n        &gt;&gt;&gt; symbolic_solution_quot(et_1, et_2)\n        0.1\n    \"\"\"\n    quot_1 = simplify(e_a.sympy_expr / e_b.sympy_expr)\n    quot_2 = simplify(e_a.sympy_expr / e_b.sympy_expr)\n    if quot_1.is_constant():\n        return min(float(quot_1), float(quot_2))\n    else:\n        return np.infty\n</code></pre>"},{"location":"reference/src/equation_tree/src/","title":"Src","text":""},{"location":"reference/src/equation_tree/src/sample_tree_structure/","title":"Sample tree structure","text":""},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure","title":"<code>sample_tree_structure(prior={})</code>","text":"<p>Sample a tree structure.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Dict</code> <p>priors in form of a dictionary. The keys are the tree structures as strings</p> <code>{}</code> <p>Examples:</p>"},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure--set-seed-for-reproducibility","title":"Set seed for reproducibility","text":"<pre><code>&gt;&gt;&gt; np.random.seed(42)\n</code></pre> <pre><code>&gt;&gt;&gt; [sample_tree_structure({'[0, 1, 1]': 1}) for _ in range(4)]\n[[0, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 1]]\n</code></pre> <pre><code>&gt;&gt;&gt; [sample_tree_structure({'[0, 1, 1]': .5, '[0, 1, 2]': .5}) for _ in range(4)]\n[[0, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 2]]\n</code></pre> <pre><code>&gt;&gt;&gt; sample_tree_structure({'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 1, 2': .4})\n[0, 1, 2, 3, 1]\n</code></pre> Source code in <code>src/equation_tree/src/sample_tree_structure.py</code> <pre><code>def sample_tree_structure(prior: Dict = {}):\n    \"\"\"\n    Sample a tree structure.\n\n    Args:\n        prior: priors in form of a dictionary. The keys are the tree structures as strings\n\n    Examples:\n        # Set seed for reproducibility\n        &gt;&gt;&gt; np.random.seed(42)\n\n        &gt;&gt;&gt; [sample_tree_structure({'[0, 1, 1]': 1}) for _ in range(4)]\n        [[0, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 1]]\n\n        &gt;&gt;&gt; [sample_tree_structure({'[0, 1, 1]': .5, '[0, 1, 2]': .5}) for _ in range(4)]\n        [[0, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 2]]\n\n        &gt;&gt;&gt; sample_tree_structure({'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 1, 2': .4})\n        [0, 1, 2, 3, 1]\n\n    \"\"\"\n    tree_structures = [parse_string_list_int(str(key)) for key in prior.keys()]\n    probabilities = [prior[key] for key in prior.keys()]\n\n    for _ in range(MAX_ITER):\n        sample_index = np.random.choice(len(tree_structures), p=probabilities)\n        tree_structure = tree_structures[sample_index]\n        if not _is_binary_tree(tree_structure):\n            warnings.warn(\n                \"Found a non binary tree structure, \"\n                \"this might lead to discrepancies between set priors and sample frequencies.\"\n            )\n            continue\n        return tree_structure\n    raise Exception(f\"Could not generate tree structure with prior: {prior}\")\n</code></pre>"},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure_non_iso","title":"<code>sample_tree_structure_non_iso(max_depth, priors={})</code>","text":"<p>Sample a tree structure.</p> <p>Parameters:</p> Name Type Description Default <code>max_depth</code> <code>int</code> <p>the maximum depth of a tree</p> required <code>priors</code> <code>Dict</code> <p>priors in form of a dictionary. The keys are the tree structures as strings</p> <code>{}</code> <p>Examples:</p>"},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure_non_iso--set-seed-for-reproducibility","title":"Set seed for reproducibility","text":"<pre><code>&gt;&gt;&gt; np.random.seed(42)\n</code></pre>"},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure_non_iso--sample-a-single-structure","title":"Sample a single structure","text":"<pre><code>&gt;&gt;&gt; sample_tree_structure_non_iso(7)\n[0, 1, 2, 3, 3, 2]\n</code></pre>"},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure_non_iso--get-a-list-of-4-samples-with-max_depth-4","title":"Get a list of 4 samples with max_depth = 4","text":"<pre><code>&gt;&gt;&gt; [sample_tree_structure_non_iso(5) for _ in range(4)]\n[[0, 1, 2, 1, 2], [0, 1, 2, 3, 1], [0, 1, 2, 3, 3], [0, 1, 1]]\n</code></pre>"},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure_non_iso--set-a-prior","title":"Set a prior","text":"<pre><code>&gt;&gt;&gt; [sample_tree_structure_non_iso(5, {'[0, 1, 1]': 1}) for _ in range(4)]\n[[0, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 1]]\n</code></pre>"},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure_non_iso--set-a-different-prior","title":"Set a different prior","text":"<pre><code>&gt;&gt;&gt; [sample_tree_structure_non_iso(5, {'[0, 1, 1]': .5, '[0, 1, 2]': .5}) for _ in range(4)]\n[[0, 1, 1], [0, 1, 2], [0, 1, 1], [0, 1, 1]]\n</code></pre>"},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure_non_iso--we-can-also-set-a-full-prior-here-the-max_depth-for-the-structure-is-3-which-only-allows","title":"We can also set a full prior( here the max_depth for the structure is 3 which only allows","text":""},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure_non_iso--for-two-structures-0-1-1-and-0-1-2","title":"for two structures: [0, 1, 1] and [0, 1, 2]","text":"<pre><code>&gt;&gt;&gt; [sample_tree_structure_non_iso(3, {'[0, 1, 1]': .3, '[0, 1, 2]': .7}) for _ in range(4)]\n[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]\n</code></pre>"},{"location":"reference/src/equation_tree/src/sample_tree_structure/#src.equation_tree.src.sample_tree_structure.sample_tree_structure_non_iso--if-we-set-an-invalid-prior-an-exeption-is-raised-doctest-ellipsis","title":"If we set an invalid prior, an Exeption is raised  # doctest: +ELLIPSIS","text":"<pre><code>&gt;&gt;&gt; [sample_tree_structure_non_iso(3, {'[0, 1, 3]': .5}) for _ in range(4)]\nTraceback (most recent call last):\n...\nException: Priors {'[0, 1, 3]': 0.5} are not subset of space ['[0, 1, 2]', '[0, 1, 1]']\n</code></pre> Source code in <code>src/equation_tree/src/sample_tree_structure.py</code> <pre><code>def sample_tree_structure_non_iso(max_depth: int, priors: Dict = {}):\n    \"\"\"\n    Sample a tree structure.\n\n    Args:\n        max_depth: the maximum depth of a tree\n        priors: priors in form of a dictionary. The keys are the tree structures as strings\n\n    Examples:\n        # Set seed for reproducibility\n        &gt;&gt;&gt; np.random.seed(42)\n\n        # Sample a single structure\n        &gt;&gt;&gt; sample_tree_structure_non_iso(7)\n        [0, 1, 2, 3, 3, 2]\n\n        # Get a list of 4 samples with max_depth = 4\n        &gt;&gt;&gt; [sample_tree_structure_non_iso(5) for _ in range(4)]\n        [[0, 1, 2, 1, 2], [0, 1, 2, 3, 1], [0, 1, 2, 3, 3], [0, 1, 1]]\n\n        # Set a prior\n        &gt;&gt;&gt; [sample_tree_structure_non_iso(5, {'[0, 1, 1]': 1}) for _ in range(4)]\n        [[0, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 1]]\n\n        # Set a different prior\n        &gt;&gt;&gt; [sample_tree_structure_non_iso(5, {'[0, 1, 1]': .5, '[0, 1, 2]': .5}) for _ in range(4)]\n        [[0, 1, 1], [0, 1, 2], [0, 1, 1], [0, 1, 1]]\n\n        # We can also set a full prior( here the max_depth for the structure is 3 which only allows\n        # for two structures: [0, 1, 1] and [0, 1, 2]\n        &gt;&gt;&gt; [sample_tree_structure_non_iso(3, {'[0, 1, 1]': .3, '[0, 1, 2]': .7}) for _ in range(4)]\n        [[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]\n\n        # If we set an invalid prior, an Exeption is raised  # doctest: +ELLIPSIS\n        &gt;&gt;&gt; [sample_tree_structure_non_iso(3, {'[0, 1, 3]': .5}) for _ in range(4)]\n        Traceback (most recent call last):\n        ...\n        Exception: Priors {'[0, 1, 3]': 0.5} are not subset of space ['[0, 1, 2]', '[0, 1, 1]']\n\n    \"\"\"\n    tree_structures = _gen_all_tree_structures_non_iso(max_depth)\n\n    priors = set_priors(priors, [str(structure) for structure in tree_structures])\n    probabilities = [priors[key] for key in priors.keys()]\n\n    for _ in range(MAX_ITER):\n        sample_index = np.random.choice(len(tree_structures), p=probabilities)\n        tree_structure = tree_structures[sample_index]\n        if not _is_binary_tree(tree_structure):\n            warnings.warn(\n                \"Found a non binary tree structure, \"\n                \"this might lead to discrepancies between set priors and sample frequencies.\"\n            )\n            continue\n        return tree_structure\n    raise Exception(f\"Could not generate tree structure with max depth {max_depth}\")\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/","title":"Tree node","text":""},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.TreeNode","title":"<code>TreeNode</code>","text":"Source code in <code>src/equation_tree/src/tree_node.py</code> <pre><code>class TreeNode:\n    def __init__(\n        self,\n        left=None,\n        right=None,\n        kind=NodeKind.NONE,\n        attribute=\"\",\n    ):\n        \"\"\"\n        Examples:\n            &gt;&gt;&gt; gc_1 = TreeNode(attribute='grand_child_1')\n            &gt;&gt;&gt; gc_1.size\n            1\n            &gt;&gt;&gt; child_1 = TreeNode(attribute='child_1', left=gc_1)\n            &gt;&gt;&gt; child_1.size\n            2\n            &gt;&gt;&gt; child_2 = TreeNode(attribute='child_2')\n            &gt;&gt;&gt; child_2.size\n            1\n            &gt;&gt;&gt; root = TreeNode(left=child_1,right=child_2,attribute='root')\n            &gt;&gt;&gt; root.size\n            4\n        \"\"\"\n\n        self.attribute = attribute\n        self.kind = kind\n        self.parent = None\n        self.left = left\n        self.right = right\n        self.evaluation = 0\n\n        self.children = []\n        if left is not None:\n            self.children.append(left)\n            left.parent = self\n        if right is not None:\n            self.children.append(right)\n            right.parent = self\n        self.is_leaf = self.children == []\n\n    def check_validity(\n        self,\n        zero_representations=[\"0\"],\n        log_representations=[\"log\", \"Log\"],\n        division_representations=[\"/\", \":\"],\n        verbose=False,\n    ):\n        return check_node_validity(\n            self,\n            zero_representations,\n            log_representations,\n            division_representations,\n            verbose,\n        )\n\n    @property\n    def size(self):\n        s_ = 1\n        for c in self.children:\n            s_ += c.size\n        return s_\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.TreeNode.__init__","title":"<code>__init__(left=None, right=None, kind=NodeKind.NONE, attribute='')</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; gc_1 = TreeNode(attribute='grand_child_1')\n&gt;&gt;&gt; gc_1.size\n1\n&gt;&gt;&gt; child_1 = TreeNode(attribute='child_1', left=gc_1)\n&gt;&gt;&gt; child_1.size\n2\n&gt;&gt;&gt; child_2 = TreeNode(attribute='child_2')\n&gt;&gt;&gt; child_2.size\n1\n&gt;&gt;&gt; root = TreeNode(left=child_1,right=child_2,attribute='root')\n&gt;&gt;&gt; root.size\n4\n</code></pre> Source code in <code>src/equation_tree/src/tree_node.py</code> <pre><code>def __init__(\n    self,\n    left=None,\n    right=None,\n    kind=NodeKind.NONE,\n    attribute=\"\",\n):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; gc_1 = TreeNode(attribute='grand_child_1')\n        &gt;&gt;&gt; gc_1.size\n        1\n        &gt;&gt;&gt; child_1 = TreeNode(attribute='child_1', left=gc_1)\n        &gt;&gt;&gt; child_1.size\n        2\n        &gt;&gt;&gt; child_2 = TreeNode(attribute='child_2')\n        &gt;&gt;&gt; child_2.size\n        1\n        &gt;&gt;&gt; root = TreeNode(left=child_1,right=child_2,attribute='root')\n        &gt;&gt;&gt; root.size\n        4\n    \"\"\"\n\n    self.attribute = attribute\n    self.kind = kind\n    self.parent = None\n    self.left = left\n    self.right = right\n    self.evaluation = 0\n\n    self.children = []\n    if left is not None:\n        self.children.append(left)\n        left.parent = self\n    if right is not None:\n        self.children.append(right)\n        right.parent = self\n    self.is_leaf = self.children == []\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.edit_distance","title":"<code>edit_distance(tree_a, tree_b)</code>","text":"<p>Computes the tree edit distance between trees A and B</p> Implements the algorithm described here <p><code>Zhang, K., &amp; Shasha, D. (1989). Simple fast algorithms for the editing distance between trees and related problems. SIAM journal on computing, 18(6), 1245-1262.</code></p> <p>Inspired and adjusted(simplified) for the purpose of this repository from:     <code>https://github.com/timtadh/zhang-shasha</code></p> <p>Parameters:</p> Name Type Description Default <code>tree_a</code> <code>TreeNode</code> <p>Root of tree A</p> required <code>tree_b</code> <code>TreeNode</code> <p>Root of tree B</p> required Return <p>An integer distance [0, inf+)</p> <p>Examples:     &gt;&gt;&gt; gc_1_a = TreeNode(attribute='grand_child_1')     &gt;&gt;&gt; gc_1_b = TreeNode(attribute='grand_child_1')     &gt;&gt;&gt; edit_distance(gc_1_a, gc_1_b)     0     &gt;&gt;&gt; child_1_a = TreeNode(attribute='child_1', left=gc_1_a)     &gt;&gt;&gt; child_1_b = TreeNode(attribute='child_1_', left=gc_1_b)     &gt;&gt;&gt; edit_distance(child_1_a, child_1_b)     1     &gt;&gt;&gt; child_2_a = TreeNode(attribute='child_2')     &gt;&gt;&gt; child_2_b = TreeNode(attribute='child_2')     &gt;&gt;&gt; edit_distance(child_2_a, child_2_b)     0     &gt;&gt;&gt; root_a = TreeNode(attribute='root', left=child_1_a, right=child_2_a)     &gt;&gt;&gt; root_b = TreeNode(attribute='root', left=child_1_b, right=child_2_b)     &gt;&gt;&gt; edit_distance(root_a, root_b)     1     &gt;&gt;&gt; root_a_ = TreeNode(attribute='root', left=child_2_a, right=child_1_a)     &gt;&gt;&gt; edit_distance(root_a, root_a_)     2     &gt;&gt;&gt; edit_distance(root_a_, root_b)     3</p> Source code in <code>src/equation_tree/src/tree_node.py</code> <pre><code>def edit_distance(tree_a: TreeNode, tree_b: TreeNode):\n    \"\"\"\n    Computes the tree edit distance between trees A and B\n\n    Implements the algorithm described here:\n        `Zhang, K., &amp; Shasha, D. (1989).\n        Simple fast algorithms for the editing distance between trees and related problems.\n        SIAM journal on computing, 18(6), 1245-1262.`\n    Inspired and adjusted(simplified) for the purpose of this repository from:\n        `https://github.com/timtadh/zhang-shasha`\n\n    Args:\n        tree_a: Root of tree A\n        tree_b: Root of tree B\n\n    Return:\n        An integer distance [0, inf+)\n    Examples:\n        &gt;&gt;&gt; gc_1_a = TreeNode(attribute='grand_child_1')\n        &gt;&gt;&gt; gc_1_b = TreeNode(attribute='grand_child_1')\n        &gt;&gt;&gt; edit_distance(gc_1_a, gc_1_b)\n        0\n        &gt;&gt;&gt; child_1_a = TreeNode(attribute='child_1', left=gc_1_a)\n        &gt;&gt;&gt; child_1_b = TreeNode(attribute='child_1_', left=gc_1_b)\n        &gt;&gt;&gt; edit_distance(child_1_a, child_1_b)\n        1\n        &gt;&gt;&gt; child_2_a = TreeNode(attribute='child_2')\n        &gt;&gt;&gt; child_2_b = TreeNode(attribute='child_2')\n        &gt;&gt;&gt; edit_distance(child_2_a, child_2_b)\n        0\n        &gt;&gt;&gt; root_a = TreeNode(attribute='root', left=child_1_a, right=child_2_a)\n        &gt;&gt;&gt; root_b = TreeNode(attribute='root', left=child_1_b, right=child_2_b)\n        &gt;&gt;&gt; edit_distance(root_a, root_b)\n        1\n        &gt;&gt;&gt; root_a_ = TreeNode(attribute='root', left=child_2_a, right=child_1_a)\n        &gt;&gt;&gt; edit_distance(root_a, root_a_)\n        2\n        &gt;&gt;&gt; edit_distance(root_a_, root_b)\n        3\n\n    \"\"\"\n    tree_a_helper = _HelperTree(tree_a)\n    tree_b_helper = _HelperTree(tree_b)\n\n    treedists = np.zeros((tree_a.size, tree_b.size), float)\n\n    def update_cost(node_a, node_b):\n        return int(node_a.attribute != node_b.attribute)\n\n    def treedist(i, j):\n        al = tree_a_helper.lmds\n        bl = tree_b_helper.lmds\n\n        an = tree_a_helper.nodes\n        bn = tree_b_helper.nodes\n\n        m = i - al[i] + 2\n        n = j - bl[j] + 2\n\n        ioff = al[i] - 1\n        joff = bl[j] - 1\n\n        # Initialize the fd array\n        fd = np.zeros((m, n), float)\n        fd[1:, 0] = np.arange(1, m)\n        fd[0, 1:] = np.arange(1, n)\n\n        partial_ops = [[([1] if x == 0 else []) for x in range(n)] for _ in range(m)]\n\n        for x in range(1, m):\n            for y in range(1, n):\n                if al[i] == al[x + ioff] and bl[j] == bl[y + joff]:\n                    costs = [\n                        fd[x - 1][y] + 1,\n                        fd[x][y - 1] + 1,\n                        fd[x - 1][y - 1] + update_cost(an[x + ioff], bn[y + joff]),\n                    ]\n                    fd[x][y] = min(costs)\n                    min_index = costs.index(fd[x][y])\n                    if min_index == 0:\n                        partial_ops[x][y] = partial_ops[x - 1][y] + [1]\n                    elif min_index == 1:\n                        partial_ops[x][y] = partial_ops[x][y - 1] + [1]\n                    else:\n                        partial_ops[x][y] = partial_ops[x - 1][y - 1] + [1]\n\n                    treedists[x + ioff][y + joff] = fd[x][y]\n                else:\n                    p = al[x + ioff] - 1 - ioff\n                    q = bl[y + joff] - 1 - joff\n                    costs = [\n                        fd[x - 1][y] + 1,\n                        fd[x][y - 1] + 1,\n                        fd[p][q] + treedists[x + ioff][y + joff],\n                    ]\n                    fd[x][y] = min(costs)\n                    min_index = costs.index(fd[x][y])\n                    if min_index == 0:\n                        partial_ops[x][y] = partial_ops[x - 1][y] + [1]\n                    elif min_index == 1:\n                        partial_ops[x][y] = partial_ops[x][y - 1] + [1]\n                    else:\n                        partial_ops[x][y] = partial_ops[p][q] + [1]\n\n    for i in tree_a_helper.keyroots:\n        for j in tree_b_helper.keyroots:\n            treedist(i, j)\n    return int(treedists[-1][-1])\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.ned","title":"<code>ned(tree_a, tree_b)</code>","text":"<p>Normalized tree edit distance according to: <code>Li, Y., &amp; Chenguang, Z. (2011). A metric normalization of tree edit distance. Frontiers of Computer Science in China, 5, 119-125.</code> Examples:     &gt;&gt;&gt; gc_1_a = TreeNode(attribute='grand_child_1')     &gt;&gt;&gt; gc_1_b = TreeNode(attribute='grand_child_1')     &gt;&gt;&gt; ned(gc_1_a, gc_1_b)     0.0     &gt;&gt;&gt; child_1_a = TreeNode(attribute='child_1', left=gc_1_a)     &gt;&gt;&gt; child_1_b = TreeNode(attribute='child_1_', left=gc_1_b)     &gt;&gt;&gt; ned(child_1_a, child_1_b)     0.4     &gt;&gt;&gt; child_2_a = TreeNode(attribute='child_2')     &gt;&gt;&gt; child_2_b = TreeNode(attribute='child_2')     &gt;&gt;&gt; ned(child_2_a, child_2_b)     0.0     &gt;&gt;&gt; root_a = TreeNode(attribute='root', left=child_1_a, right=child_2_a)     &gt;&gt;&gt; root_b = TreeNode(attribute='root', left=child_1_b, right=child_2_b)     &gt;&gt;&gt; ned(root_a, root_b)     0.2222222222222222     &gt;&gt;&gt; root_a_ = TreeNode(attribute='root', left=child_2_a, right=child_1_a)     &gt;&gt;&gt; ned(root_a, root_a_)     0.4     &gt;&gt;&gt; ned(root_a_, root_b)     0.5454545454545454</p> Source code in <code>src/equation_tree/src/tree_node.py</code> <pre><code>def ned(tree_a: TreeNode, tree_b: TreeNode):\n    \"\"\"\n    Normalized tree edit distance according to:\n    `Li, Y., &amp; Chenguang, Z. (2011). A metric normalization of tree edit distance.\n    Frontiers of Computer Science in China, 5, 119-125.`\n    Examples:\n        &gt;&gt;&gt; gc_1_a = TreeNode(attribute='grand_child_1')\n        &gt;&gt;&gt; gc_1_b = TreeNode(attribute='grand_child_1')\n        &gt;&gt;&gt; ned(gc_1_a, gc_1_b)\n        0.0\n        &gt;&gt;&gt; child_1_a = TreeNode(attribute='child_1', left=gc_1_a)\n        &gt;&gt;&gt; child_1_b = TreeNode(attribute='child_1_', left=gc_1_b)\n        &gt;&gt;&gt; ned(child_1_a, child_1_b)\n        0.4\n        &gt;&gt;&gt; child_2_a = TreeNode(attribute='child_2')\n        &gt;&gt;&gt; child_2_b = TreeNode(attribute='child_2')\n        &gt;&gt;&gt; ned(child_2_a, child_2_b)\n        0.0\n        &gt;&gt;&gt; root_a = TreeNode(attribute='root', left=child_1_a, right=child_2_a)\n        &gt;&gt;&gt; root_b = TreeNode(attribute='root', left=child_1_b, right=child_2_b)\n        &gt;&gt;&gt; ned(root_a, root_b)\n        0.2222222222222222\n        &gt;&gt;&gt; root_a_ = TreeNode(attribute='root', left=child_2_a, right=child_1_a)\n        &gt;&gt;&gt; ned(root_a, root_a_)\n        0.4\n        &gt;&gt;&gt; ned(root_a_, root_b)\n        0.5454545454545454\n    \"\"\"\n    ed = edit_distance(tree_a, tree_b)\n    return 2 * ed / (tree_a.size + tree_b.size + ed)\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.node_from_prefix","title":"<code>node_from_prefix(prefix_notation, function_test=lambda : False, operator_test=lambda : False, variable_test=lambda : False, constant_test=lambda : False)</code>","text":"<p>Create a tree from a prefix notation</p> <p>Parameters:</p> Name Type Description Default <code>prefix_notation</code> <code>List[str]</code> <p>The equation in prefix notation</p> required <code>function_test</code> <code>Callable</code> <p>A function that tests if the attribute is a function</p> <code>lambda : False</code> <code>operator_test</code> <code>Callable</code> <p>A function that tests if the attribute is an operator</p> <code>lambda : False</code> <code>variable_test</code> <code>Callable</code> <p>A function that tests if the attribute is a variable</p> <code>lambda : False</code> <code>constant_test</code> <code>Callable</code> <p>A function that tests if the attribute is a constant</p> <code>lambda : False</code> <p>Examples:</p>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.node_from_prefix--the-equation-is-a-single-variable-the-test-for-variables-is-a-check-in-a-hard","title":"The equation is a single variable. The test for variables is a check in a hard","text":""},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.node_from_prefix--coded-list","title":"coded list","text":"<pre><code>&gt;&gt;&gt; tree = node_from_prefix(['x'], variable_test=lambda x: 'x' in ['x', 'y', 'z'])\n&gt;&gt;&gt; tree.kind == NodeKind.VARIABLE\nTrue\n&gt;&gt;&gt; tree.attribute\n'x'\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.node_from_prefix--we-can-also-use-more-elaborate-tests-depending-for-example-checking-weather-the","title":"We can also use more elaborate tests depending. For example checking, weather the","text":""},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.node_from_prefix--attribute-contains-an-underscore","title":"attribute contains an underscore","text":"<pre><code>&gt;&gt;&gt; tree = node_from_prefix(\n...     prefix_notation=['sin', 'x_1'],\n...     function_test=lambda x: x in ['sin', 'cos'],\n...     variable_test=lambda x: '_' in x)\n&gt;&gt;&gt; tree.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; tree.attribute\n'sin'\n&gt;&gt;&gt; tree.left.kind == NodeKind.VARIABLE\nTrue\n&gt;&gt;&gt; tree.left.attribute\n'x_1'\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.node_from_prefix--we-can-also-pass-other-functions","title":"We can also pass other functions","text":"<pre><code>&gt;&gt;&gt; def is_variable(x):\n...     return x == 'x' or x == 'y'\n&gt;&gt;&gt; def is_operator(x):\n...     return not is_variable(x) and len(x) == 1\n&gt;&gt;&gt; def is_function(x):\n...     return not is_variable(x) and not is_operator(x)\n&gt;&gt;&gt; tree = node_from_prefix(\n...     prefix_notation=['+', 'sin', 'x', 'cos', 'y'],\n...     variable_test=is_variable,\n...     operator_test=is_operator,\n...     function_test=is_function\n...     )\n&gt;&gt;&gt; tree.kind == NodeKind.OPERATOR\nTrue\n&gt;&gt;&gt; tree.attribute\n'+'\n&gt;&gt;&gt; tree.left.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; tree.left.attribute\n'sin'\n&gt;&gt;&gt; tree.left.left.kind == NodeKind.VARIABLE\nTrue\n&gt;&gt;&gt; tree.left.left.attribute\n'x'\n&gt;&gt;&gt; tree.right.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; tree.right.attribute\n'cos'\n&gt;&gt;&gt; tree.right.left.kind == NodeKind.VARIABLE\nTrue\n&gt;&gt;&gt; tree.right.left.attribute\n'y'\n</code></pre> Source code in <code>src/equation_tree/src/tree_node.py</code> <pre><code>def node_from_prefix(\n    prefix_notation: List[str],\n    function_test: Callable = lambda _: False,\n    operator_test: Callable = lambda _: False,\n    variable_test: Callable = lambda _: False,\n    constant_test: Callable = lambda _: False,\n):\n    \"\"\"\n    Create a tree from a prefix notation\n\n    Args:\n        prefix_notation: The equation in prefix notation\n        function_test: A function that tests if the attribute is a function\n        operator_test: A function that tests if the attribute is an operator\n        variable_test: A function that tests if the attribute is a variable\n        constant_test: A function that tests if the attribute is a constant\n\n    Examples:\n        # The equation is a single variable. The test for variables is a check in a hard\n        # coded list\n        &gt;&gt;&gt; tree = node_from_prefix(['x'], variable_test=lambda x: 'x' in ['x', 'y', 'z'])\n        &gt;&gt;&gt; tree.kind == NodeKind.VARIABLE\n        True\n        &gt;&gt;&gt; tree.attribute\n        'x'\n\n        # We can also use more elaborate tests depending. For example checking, weather the\n        # attribute contains an underscore\n        &gt;&gt;&gt; tree = node_from_prefix(\n        ...     prefix_notation=['sin', 'x_1'],\n        ...     function_test=lambda x: x in ['sin', 'cos'],\n        ...     variable_test=lambda x: '_' in x)\n        &gt;&gt;&gt; tree.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; tree.attribute\n        'sin'\n        &gt;&gt;&gt; tree.left.kind == NodeKind.VARIABLE\n        True\n        &gt;&gt;&gt; tree.left.attribute\n        'x_1'\n\n        # We can also pass other functions\n        &gt;&gt;&gt; def is_variable(x):\n        ...     return x == 'x' or x == 'y'\n        &gt;&gt;&gt; def is_operator(x):\n        ...     return not is_variable(x) and len(x) == 1\n        &gt;&gt;&gt; def is_function(x):\n        ...     return not is_variable(x) and not is_operator(x)\n        &gt;&gt;&gt; tree = node_from_prefix(\n        ...     prefix_notation=['+', 'sin', 'x', 'cos', 'y'],\n        ...     variable_test=is_variable,\n        ...     operator_test=is_operator,\n        ...     function_test=is_function\n        ...     )\n        &gt;&gt;&gt; tree.kind == NodeKind.OPERATOR\n        True\n        &gt;&gt;&gt; tree.attribute\n        '+'\n        &gt;&gt;&gt; tree.left.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; tree.left.attribute\n        'sin'\n        &gt;&gt;&gt; tree.left.left.kind == NodeKind.VARIABLE\n        True\n        &gt;&gt;&gt; tree.left.left.attribute\n        'x'\n        &gt;&gt;&gt; tree.right.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; tree.right.attribute\n        'cos'\n        &gt;&gt;&gt; tree.right.left.kind == NodeKind.VARIABLE\n        True\n        &gt;&gt;&gt; tree.right.left.attribute\n        'y'\n\n    \"\"\"\n    node, _ = _from_prefix_recursion(\n        prefix_notation, function_test, operator_test, variable_test, constant_test\n    )\n\n    return node\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full","title":"<code>sample_tree_full(prior, max_var_unique)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; np.random.seed(42)\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full--we-can-set-priors-for-features-functions-operators","title":"We can set priors for features, functions, operators","text":""},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full--and-also-conditionals-based-the-parent","title":"and also conditionals based the parent","text":"<pre><code>&gt;&gt;&gt; p = {\n...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n...     'features': {'constants': .2, 'variables': .8},\n...     'functions': {'sin': .5, 'cos': .5},\n...     'operators': {'+': 1., '-': .0},\n...     'function_conditionals': {\n...                             'sin': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'sin': 0., 'cos': 1.},\n...                                 'operators': {'+': 0., '-': 1.}\n...                             },\n...                             'cos': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'cos': 1., 'sin': 0.},\n...                                 'operators': {'+': 0., '-': 1.}\n...                             }\n...                         },\n...     'operator_conditionals': {\n...                             '+': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'sin': 1., 'cos': 0.},\n...                                 'operators': {'+': 1., '-': 0.}\n...                             },\n...                             '-': {\n...                                 'features': {'constants': .3, 'variables': .7},\n...                                 'functions': {'cos': .5, 'sin': .5},\n...                                 'operators': {'+': .9, '-': .1}\n...                             }\n...                         },\n... }\n&gt;&gt;&gt; sample = sample_tree_full(p, 3)\n&gt;&gt;&gt; sample.attribute\n'cos'\n&gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; sample.left.attribute\n'cos'\n&gt;&gt;&gt; sample.left.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; sample.right is None\nTrue\n&gt;&gt;&gt; sample = sample_tree_full(p, 3)\n&gt;&gt;&gt; sample.attribute\n'sin'\n&gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; sample.left.attribute\n'cos'\n&gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; sample.left.left.attribute\n'x_1'\n&gt;&gt;&gt; sample.left.left.kind == NodeKind.VARIABLE\nTrue\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full--if-we-dont-provide-priors-for-the-conditionals","title":"If we don't provide priors for the conditionals,","text":""},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full--the-fallback-is-the-unconditioned-priors","title":"the fallback is the unconditioned priors","text":"<pre><code>&gt;&gt;&gt; p = {'max_depth': 8,\n...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n...     'features': {'constants': .2, 'variables': .8},\n...     'functions': {'sin': .5, 'cos': .5},\n...     'operators': {'+': .5, '-': .5},\n... }\n&gt;&gt;&gt; sample = sample_tree_full(p, 3)\n&gt;&gt;&gt; sample.attribute\n'-'\n&gt;&gt;&gt; sample.kind == NodeKind.OPERATOR\nTrue\n&gt;&gt;&gt; sample.right.attribute\n'x_1'\n&gt;&gt;&gt; sample.left.attribute\n'x_1'\n&gt;&gt;&gt; sample.left.kind == NodeKind.VARIABLE\nTrue\n</code></pre> Source code in <code>src/equation_tree/src/tree_node.py</code> <pre><code>def sample_tree_full(prior, max_var_unique):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; np.random.seed(42)\n\n        # We can set priors for features, functions, operators\n        # and also conditionals based the parent\n        &gt;&gt;&gt; p = {\n        ...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n        ...     'features': {'constants': .2, 'variables': .8},\n        ...     'functions': {'sin': .5, 'cos': .5},\n        ...     'operators': {'+': 1., '-': .0},\n        ...     'function_conditionals': {\n        ...                             'sin': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'sin': 0., 'cos': 1.},\n        ...                                 'operators': {'+': 0., '-': 1.}\n        ...                             },\n        ...                             'cos': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'cos': 1., 'sin': 0.},\n        ...                                 'operators': {'+': 0., '-': 1.}\n        ...                             }\n        ...                         },\n        ...     'operator_conditionals': {\n        ...                             '+': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'sin': 1., 'cos': 0.},\n        ...                                 'operators': {'+': 1., '-': 0.}\n        ...                             },\n        ...                             '-': {\n        ...                                 'features': {'constants': .3, 'variables': .7},\n        ...                                 'functions': {'cos': .5, 'sin': .5},\n        ...                                 'operators': {'+': .9, '-': .1}\n        ...                             }\n        ...                         },\n        ... }\n        &gt;&gt;&gt; sample = sample_tree_full(p, 3)\n        &gt;&gt;&gt; sample.attribute\n        'cos'\n        &gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; sample.left.attribute\n        'cos'\n        &gt;&gt;&gt; sample.left.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; sample.right is None\n        True\n        &gt;&gt;&gt; sample = sample_tree_full(p, 3)\n        &gt;&gt;&gt; sample.attribute\n        'sin'\n        &gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; sample.left.attribute\n        'cos'\n        &gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; sample.left.left.attribute\n        'x_1'\n        &gt;&gt;&gt; sample.left.left.kind == NodeKind.VARIABLE\n        True\n\n        # If we don't provide priors for the conditionals,\n        # the fallback is the unconditioned priors\n        &gt;&gt;&gt; p = {'max_depth': 8,\n        ...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n        ...     'features': {'constants': .2, 'variables': .8},\n        ...     'functions': {'sin': .5, 'cos': .5},\n        ...     'operators': {'+': .5, '-': .5},\n        ... }\n        &gt;&gt;&gt; sample = sample_tree_full(p, 3)\n        &gt;&gt;&gt; sample.attribute\n        '-'\n        &gt;&gt;&gt; sample.kind == NodeKind.OPERATOR\n        True\n        &gt;&gt;&gt; sample.right.attribute\n        'x_1'\n        &gt;&gt;&gt; sample.left.attribute\n        'x_1'\n        &gt;&gt;&gt; sample.left.kind == NodeKind.VARIABLE\n        True\n\n    \"\"\"\n    tree_structure = sample_tree_structure(prior[\"structures\"])\n    function_conditionals = None\n    operator_conditionals = None\n    if \"function_conditionals\" in prior.keys():\n        function_conditionals = prior[\"function_conditionals\"]\n    if \"operator_conditionals\" in prior.keys():\n        operator_conditionals = prior[\"operator_conditionals\"]\n\n    tree = sample_equation_tree_from_structure_with_conditionals(\n        tree_structure,\n        0,\n        prior[\"features\"],\n        prior[\"functions\"],\n        function_conditionals,\n        prior[\"operators\"],\n        operator_conditionals,\n    )\n    post(tree, max_var_unique)\n    return tree\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full_fast","title":"<code>sample_tree_full_fast(prior, tree_depth, max_var_unique)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; np.random.seed(42)\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full_fast--we-can-set-priors-for-features-functions-operators","title":"We can set priors for features, functions, operators","text":""},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full_fast--and-also-conditionals-based-the-parent","title":"and also conditionals based the parent","text":"<pre><code>&gt;&gt;&gt; p = {\n...     'features': {'constants': .2, 'variables': .8},\n...     'functions': {'sin': .5, 'cos': .5},\n...     'operators': {'+': 1., '-': .0},\n...     'function_conditionals': {\n...                             'sin': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'sin': 0., 'cos': 1.},\n...                                 'operators': {'+': 0., '-': 1.}\n...                             },\n...                             'cos': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'cos': 1., 'sin': 0.},\n...                                 'operators': {'+': 0., '-': 1.}\n...                             }\n...                         },\n...     'operator_conditionals': {\n...                             '+': {\n...                                 'features': {'constants': 0., 'variables': 1.},\n...                                 'functions': {'sin': 1., 'cos': 0.},\n...                                 'operators': {'+': 1., '-': 0.}\n...                             },\n...                             '-': {\n...                                 'features': {'constants': .3, 'variables': .7},\n...                                 'functions': {'cos': .5, 'sin': .5},\n...                                 'operators': {'+': .9, '-': .1}\n...                             }\n...                         },\n... }\n&gt;&gt;&gt; sample = sample_tree_full_fast(p, 3, 2)\n&gt;&gt;&gt; sample.attribute\n'cos'\n&gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; sample.left.attribute\n'cos'\n&gt;&gt;&gt; sample.left.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; sample.right is None\nTrue\n&gt;&gt;&gt; sample = sample_tree_full_fast(p, 4, 3)\n&gt;&gt;&gt; sample.attribute\n'sin'\n&gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; sample.left.attribute\n'-'\n&gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\nTrue\n&gt;&gt;&gt; sample.left.left.attribute\n'x_1'\n&gt;&gt;&gt; sample.left.left.kind == NodeKind.VARIABLE\nTrue\n</code></pre>"},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full_fast--if-we-dont-provide-priors-for-the-conditionals","title":"If we don't provide priors for the conditionals,","text":""},{"location":"reference/src/equation_tree/src/tree_node/#src.equation_tree.src.tree_node.sample_tree_full_fast--the-fallback-is-the-unconditioned-priors","title":"the fallback is the unconditioned priors","text":"<pre><code>&gt;&gt;&gt; p = {'max_depth': 8,\n...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n...     'features': {'constants': .2, 'variables': .8},\n...     'functions': {'sin': .5, 'cos': .5},\n...     'operators': {'+': .5, '-': .5},\n... }\n&gt;&gt;&gt; sample = sample_tree_full_fast(p, 5, 3)\n&gt;&gt;&gt; sample.attribute\n'-'\n&gt;&gt;&gt; sample.kind == NodeKind.OPERATOR\nTrue\n&gt;&gt;&gt; sample.right.attribute\n'cos'\n&gt;&gt;&gt; sample.left.attribute\n'sin'\n&gt;&gt;&gt; sample.left.kind == NodeKind.FUNCTION\nTrue\n</code></pre> Source code in <code>src/equation_tree/src/tree_node.py</code> <pre><code>def sample_tree_full_fast(prior, tree_depth, max_var_unique):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; np.random.seed(42)\n\n        # We can set priors for features, functions, operators\n        # and also conditionals based the parent\n        &gt;&gt;&gt; p = {\n        ...     'features': {'constants': .2, 'variables': .8},\n        ...     'functions': {'sin': .5, 'cos': .5},\n        ...     'operators': {'+': 1., '-': .0},\n        ...     'function_conditionals': {\n        ...                             'sin': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'sin': 0., 'cos': 1.},\n        ...                                 'operators': {'+': 0., '-': 1.}\n        ...                             },\n        ...                             'cos': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'cos': 1., 'sin': 0.},\n        ...                                 'operators': {'+': 0., '-': 1.}\n        ...                             }\n        ...                         },\n        ...     'operator_conditionals': {\n        ...                             '+': {\n        ...                                 'features': {'constants': 0., 'variables': 1.},\n        ...                                 'functions': {'sin': 1., 'cos': 0.},\n        ...                                 'operators': {'+': 1., '-': 0.}\n        ...                             },\n        ...                             '-': {\n        ...                                 'features': {'constants': .3, 'variables': .7},\n        ...                                 'functions': {'cos': .5, 'sin': .5},\n        ...                                 'operators': {'+': .9, '-': .1}\n        ...                             }\n        ...                         },\n        ... }\n        &gt;&gt;&gt; sample = sample_tree_full_fast(p, 3, 2)\n        &gt;&gt;&gt; sample.attribute\n        'cos'\n        &gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; sample.left.attribute\n        'cos'\n        &gt;&gt;&gt; sample.left.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; sample.right is None\n        True\n        &gt;&gt;&gt; sample = sample_tree_full_fast(p, 4, 3)\n        &gt;&gt;&gt; sample.attribute\n        'sin'\n        &gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; sample.left.attribute\n        '-'\n        &gt;&gt;&gt; sample.kind == NodeKind.FUNCTION\n        True\n        &gt;&gt;&gt; sample.left.left.attribute\n        'x_1'\n        &gt;&gt;&gt; sample.left.left.kind == NodeKind.VARIABLE\n        True\n\n        # If we don't provide priors for the conditionals,\n        # the fallback is the unconditioned priors\n        &gt;&gt;&gt; p = {'max_depth': 8,\n        ...     'structures': {'[0, 1, 1]': .3, '[0, 1, 2]': .3, '[0, 1, 2, 3, 2, 3, 1]': .4},\n        ...     'features': {'constants': .2, 'variables': .8},\n        ...     'functions': {'sin': .5, 'cos': .5},\n        ...     'operators': {'+': .5, '-': .5},\n        ... }\n        &gt;&gt;&gt; sample = sample_tree_full_fast(p, 5, 3)\n        &gt;&gt;&gt; sample.attribute\n        '-'\n        &gt;&gt;&gt; sample.kind == NodeKind.OPERATOR\n        True\n        &gt;&gt;&gt; sample.right.attribute\n        'cos'\n        &gt;&gt;&gt; sample.left.attribute\n        'sin'\n        &gt;&gt;&gt; sample.left.kind == NodeKind.FUNCTION\n        True\n\n    \"\"\"\n    tree_structure = sample_tree_structure_fast(tree_depth)\n    function_conditionals = None\n    operator_conditionals = None\n    if \"function_conditionals\" in prior.keys():\n        function_conditionals = prior[\"function_conditionals\"]\n    if \"operator_conditionals\" in prior.keys():\n        operator_conditionals = prior[\"operator_conditionals\"]\n\n    tree = sample_equation_tree_from_structure_with_conditionals(\n        tree_structure,\n        0,\n        prior[\"features\"],\n        prior[\"functions\"],\n        function_conditionals,\n        prior[\"operators\"],\n        operator_conditionals,\n    )\n    post(tree, max_var_unique)\n    return tree\n</code></pre>"},{"location":"reference/src/equation_tree/util/","title":"Util","text":""},{"location":"reference/src/equation_tree/util/conversions/","title":"Conversions","text":""},{"location":"reference/src/equation_tree/util/conversions/#src.equation_tree.util.conversions.func_to_op_const","title":"<code>func_to_op_const(expr)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; e_1 = 'x_1*cubed(x_1*3-squared(c_1/x_1*2)-x_3)-squared(x)'\n&gt;&gt;&gt; func_to_op_const(e_1)\n'x_1*(x_1*3-(c_1/x_1*2)**2-x_3)**3-(x)**2'\n&gt;&gt;&gt; func_to_op_const('cubed(x_1)')\n'(x_1)**3'\n</code></pre> Source code in <code>src/equation_tree/util/conversions.py</code> <pre><code>def func_to_op_const(expr):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; e_1 = 'x_1*cubed(x_1*3-squared(c_1/x_1*2)-x_3)-squared(x)'\n        &gt;&gt;&gt; func_to_op_const(e_1)\n        'x_1*(x_1*3-(c_1/x_1*2)**2-x_3)**3-(x)**2'\n        &gt;&gt;&gt; func_to_op_const('cubed(x_1)')\n        '(x_1)**3'\n    \"\"\"\n    for key, el in CONVERSIONS_FUNC_OP_CONST.items():\n        expr = _func_op_const_rec(expr, key, el)\n    return expr\n</code></pre>"},{"location":"reference/src/equation_tree/util/conversions/#src.equation_tree.util.conversions.infix_to_prefix","title":"<code>infix_to_prefix(infix, function_test, operator_test)</code>","text":"<p>Transforms prefix notation to infix notation</p> Example <p>is_function = lambda x: x in ['sin', 'cos'] is_operator = lambda x : x in ['+', '-', '*', '/'] infix_to_prefix('x_2-x_1', is_function, is_operator) ['-', 'x_2', 'x_1']</p> <p>infix_to_prefix('x_1-(x_2+x_4)', is_function, is_operator) ['-', 'x_1', '+', 'x_2', 'x_4']</p> <p>infix_to_prefix('x_1cos(c_1+x_2)', is_function, is_operator) ['', 'x_1', 'cos', '+', 'c_1', 'x_2']</p> <p>is_function = lambda x: x in ['sin', 'cos', 'e'] is_operator = lambda x: x in ['+', '-', '', '^', 'max', '*', '/'] infix_to_prefix('x_1 + max(x_2, x_3)', is_function, is_operator) ['+', 'x_1', 'max', 'x_2', 'x_3']</p> <p>infix_to_prefix('x_1-(x_2/(x_3-x_4))',is_function, is_operator) ['-', 'x_1', '/', 'x_2', '-', 'x_3', 'x_4']</p> <p>infix_to_prefix('x_1^(sin(x_2)/x_3)', is_function, is_operator) ['^', 'x_1', '/', 'sin', 'x_2', 'x_3']</p> <p>infix_to_prefix('sin(x_1)-x_2', is_function, is_operator) ['-', 'sin', 'x_1', 'x_2']</p> Source code in <code>src/equation_tree/util/conversions.py</code> <pre><code>def infix_to_prefix(infix, function_test, operator_test):\n    \"\"\"\n    Transforms prefix notation to infix notation\n\n    Example:\n        &gt;&gt;&gt; is_function = lambda x: x in ['sin', 'cos']\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '-', '*', '/']\n        &gt;&gt;&gt; infix_to_prefix('x_2-x_1', is_function, is_operator)\n        ['-', 'x_2', 'x_1']\n\n        &gt;&gt;&gt; infix_to_prefix('x_1-(x_2+x_4)', is_function, is_operator)\n        ['-', 'x_1', '+', 'x_2', 'x_4']\n\n        &gt;&gt;&gt; infix_to_prefix('x_1*cos(c_1+x_2)', is_function, is_operator)\n        ['*', 'x_1', 'cos', '+', 'c_1', 'x_2']\n\n        &gt;&gt;&gt; is_function = lambda x: x in ['sin', 'cos', 'e']\n        &gt;&gt;&gt; is_operator = lambda x: x in ['+', '-', '*', '^', 'max', '**', '/']\n        &gt;&gt;&gt; infix_to_prefix('x_1 + max(x_2, x_3)', is_function, is_operator)\n        ['+', 'x_1', 'max', 'x_2', 'x_3']\n\n        &gt;&gt;&gt; infix_to_prefix('x_1-(x_2/(x_3-x_4))',is_function, is_operator)\n        ['-', 'x_1', '/', 'x_2', '-', 'x_3', 'x_4']\n\n        &gt;&gt;&gt; infix_to_prefix('x_1^(sin(x_2)/x_3)', is_function, is_operator)\n        ['^', 'x_1', '/', 'sin', 'x_2', 'x_3']\n\n        &gt;&gt;&gt; infix_to_prefix('sin(x_1)-x_2', is_function, is_operator)\n        ['-', 'sin', 'x_1', 'x_2']\n    \"\"\"\n\n    # n = len(infix)\n\n    # infix = list(infix[::-1].lower())\n    #\n    # for i in range(n):\n    #     if infix[i] == \"(\":\n    #         infix[i] = \")\"\n    #     elif infix[i] == \")\":\n    #         infix[i] = \"(\"\n    #\n    # infix = \"\".join(infix)\n    postfix = _infix_to_postfix(infix, function_test, operator_test)\n    prefix = postfix[::-1]\n\n    return prefix\n</code></pre>"},{"location":"reference/src/equation_tree/util/conversions/#src.equation_tree.util.conversions.op_const_to_func","title":"<code>op_const_to_func(expr)</code>","text":"<p>Known operators with constants to functions. For exampl, e2-&gt;squared Examples:     &gt;&gt;&gt; op_const_to_func('x_1(x_13-(c_1/x_1*2)2-x_3)3-(x)2')     'x_1cubed(x_13-squared(c_1/x_12)-x_3)-squared(x)'     &gt;&gt;&gt; op_const_to_func('(x_1)3')     'cubed(x_1)'     &gt;&gt;&gt; op_const_to_func('x2')     'squared(x)'     &gt;&gt;&gt; op_const_to_func('c_13')     'cubed(c_1)'     &gt;&gt;&gt; op_const_to_func('(x_2*2)')     'squared(x_2)'</p> Source code in <code>src/equation_tree/util/conversions.py</code> <pre><code>def op_const_to_func(expr):\n    \"\"\"\n    Known operators with constants to functions. For exampl, e**2-&gt;squared\n    Examples:\n        &gt;&gt;&gt; op_const_to_func('x_1*(x_1*3-(c_1/x_1*2)**2-x_3)**3-(x)**2')\n        'x_1*cubed(x_1*3-squared(c_1/x_1*2)-x_3)-squared(x)'\n        &gt;&gt;&gt; op_const_to_func('(x_1)**3')\n        'cubed(x_1)'\n        &gt;&gt;&gt; op_const_to_func('x**2')\n        'squared(x)'\n        &gt;&gt;&gt; op_const_to_func('c_1**3')\n        'cubed(c_1)'\n        &gt;&gt;&gt; op_const_to_func('(x_2**2)')\n        'squared(x_2)'\n    \"\"\"\n\n    for key, el in CONVERSION_OP_CONST_FUNC.items():\n        expr = _op_const_func_rec(expr, key, el)\n    expr = _remove_unnecessary_parentheses(expr)\n\n    return expr\n</code></pre>"},{"location":"reference/src/equation_tree/util/conversions/#src.equation_tree.util.conversions.prefix_to_infix","title":"<code>prefix_to_infix(prefix, function_test=lambda : False, operator_test=lambda : False)</code>","text":"<p>Transforms prefix notation to infix notation</p> Example <p>is_function = lambda x: x in ['sin', 'cos'] is_operator = lambda x : x in ['+', '-', '', 'max', '*'] prefix_to_infix(['-', 'x_1', 'x_2'], is_function, is_operator) '(x_1-x_2)'</p> <p>prefix_to_infix( ...     ['', 'x', 'cos', '+', 'y', 'z'], is_function, is_operator) '(xcos((y+z)))'</p> <p>prefix_to_infix(['max', 'x_1', 'x_2'], is_function, is_operator) 'max(x_1,x_2)'</p> <p>prefix_to_infix(['', 'x_1', 'x_2'], is_function, is_operator) '(x_1x_2)'</p> Source code in <code>src/equation_tree/util/conversions.py</code> <pre><code>def prefix_to_infix(\n    prefix, function_test=lambda _: False, operator_test=lambda _: False\n):\n    \"\"\"\n    Transforms prefix notation to infix notation\n\n    Example:\n        &gt;&gt;&gt; is_function = lambda x: x in ['sin', 'cos']\n        &gt;&gt;&gt; is_operator = lambda x : x in ['+', '-', '*', 'max', '**']\n        &gt;&gt;&gt; prefix_to_infix(['-', 'x_1', 'x_2'], is_function, is_operator)\n        '(x_1-x_2)'\n\n        &gt;&gt;&gt; prefix_to_infix(\n        ...     ['*', 'x', 'cos', '+', 'y', 'z'], is_function, is_operator)\n        '(x*cos((y+z)))'\n\n        &gt;&gt;&gt; prefix_to_infix(['max', 'x_1', 'x_2'], is_function, is_operator)\n        'max(x_1,x_2)'\n\n        &gt;&gt;&gt; prefix_to_infix(['**', 'x_1', 'x_2'], is_function, is_operator)\n        '(x_1**x_2)'\n\n    \"\"\"\n    stack = []\n    for i in range(len(prefix) - 1, -1, -1):\n        if function_test(prefix[i]):\n            # symbol in unary operator\n            stack.append(prefix[i] + \"(\" + stack.pop() + \")\")\n        elif (operator_test(prefix[i]) or prefix[i] == \"**\") and prefix[i] in [\n            \"+\",\n            \"-\",\n            \"/\",\n            \"^\",\n            \"*\",\n            \"**\",\n        ]:\n            # symbol is binary operator\n            str = \"(\" + stack.pop() + prefix[i] + stack.pop() + \")\"\n            stack.append(str)\n        elif operator_test(prefix[i]):\n            str = prefix[i] + \"(\" + stack.pop() + \",\" + stack.pop() + \")\"\n            stack.append(str)\n        else:\n            # symbol is operand\n            stack.append(prefix[i])\n    return stack.pop()\n</code></pre>"},{"location":"reference/src/equation_tree/util/conversions/#src.equation_tree.util.conversions.standardize_sympy","title":"<code>standardize_sympy(sympy_expr, variable_test=lambda : False, constant_test=lambda : False)</code>","text":"<p>replace all variables and constants with standards</p> Example <p>from sympy import sympify expr = sympify('x + A * cos(z+y)') expr A*cos(y + z) + x</p> <p>is_variable = lambda x : x in ['x', 'y', 'z'] is_constant = lambda x : x in ['A'] standardize_sympy(expr, is_variable, is_constant) c_1*cos(x_2 + x_3) + x_1</p> <p>expr = sympify('x_a+By') expr By + x_a is_variable = lambda x : '_' in x or x in ['y'] is_constant = lambda x : x == 'B' standardize_sympy(expr, is_variable, is_constant) c_1*x_2 + x_1</p> <p>expr = sympify('x ** x') expr xx is_variable = lambda x: x in ['x'] standardize_sympy(expr, is_variable) x_1x_1</p> <p>expr = sympify('sin(Cx) + cos(Cx)') expr sin(Cx) + cos(Cx)</p> <p>is_variable = lambda x: x == 'x' is_constant = lambda x: x == 'C' standardize_sympy(expr, is_variable, is_constant) sin(c_1x_1) + cos(c_1x_1)</p> Source code in <code>src/equation_tree/util/conversions.py</code> <pre><code>def standardize_sympy(\n    sympy_expr, variable_test=lambda _: False, constant_test=lambda _: False\n):\n    \"\"\"\n    replace all variables and constants with standards\n\n    Example:\n        &gt;&gt;&gt; from sympy import sympify\n        &gt;&gt;&gt; expr = sympify('x + A * cos(z+y)')\n        &gt;&gt;&gt; expr\n        A*cos(y + z) + x\n\n        &gt;&gt;&gt; is_variable = lambda x : x in ['x', 'y', 'z']\n        &gt;&gt;&gt; is_constant = lambda x : x in ['A']\n        &gt;&gt;&gt; standardize_sympy(expr, is_variable, is_constant)\n        c_1*cos(x_2 + x_3) + x_1\n\n        &gt;&gt;&gt; expr = sympify('x_a+B*y')\n        &gt;&gt;&gt; expr\n        B*y + x_a\n        &gt;&gt;&gt; is_variable = lambda x : '_' in x or x in ['y']\n        &gt;&gt;&gt; is_constant = lambda x : x == 'B'\n        &gt;&gt;&gt; standardize_sympy(expr, is_variable, is_constant)\n        c_1*x_2 + x_1\n\n        &gt;&gt;&gt; expr = sympify('x ** x')\n        &gt;&gt;&gt; expr\n        x**x\n        &gt;&gt;&gt; is_variable = lambda x: x in ['x']\n        &gt;&gt;&gt; standardize_sympy(expr, is_variable)\n        x_1**x_1\n\n        &gt;&gt;&gt; expr = sympify('sin(C*x) + cos(C*x)')\n        &gt;&gt;&gt; expr\n        sin(C*x) + cos(C*x)\n\n        &gt;&gt;&gt; is_variable = lambda x: x == 'x'\n        &gt;&gt;&gt; is_constant = lambda x: x == 'C'\n        &gt;&gt;&gt; standardize_sympy(expr, is_variable, is_constant)\n        sin(c_1*x_1) + cos(c_1*x_1)\n    \"\"\"\n    variable_count = 0\n    constant_count = 0\n    variables = {}\n    constants = {}\n\n    def replace_symbols(node):\n        nonlocal variable_count, constant_count, variables, constants\n        if variable_test(str(node)):\n            if not str(node) in variables.keys():\n                variable_count += 1\n                new_symbol = symbols(f\"x_{variable_count}\")\n                variables[str(node)] = new_symbol\n            else:\n                new_symbol = variables[str(node)]\n            return new_symbol\n        elif constant_test(str(node)) and not is_numeric(str(node)):\n            if not str(node) in constants.keys():\n                constant_count += 1\n                new_symbol = symbols(f\"c_{constant_count}\")\n                constants[str(node)] = new_symbol\n            else:\n                new_symbol = constants[str(node)]\n            return new_symbol\n        else:\n            return node\n\n    def recursive_replace(node):\n        if node.is_Function or node.is_Add or node.is_Mul or node.is_Pow:\n            return node.func(*[recursive_replace(arg) for arg in node.args])\n        return replace_symbols(node)\n\n    new_expression = recursive_replace(sympy_expr)\n    return new_expression\n</code></pre>"},{"location":"reference/src/equation_tree/util/conversions/#src.equation_tree.util.conversions.unary_minus_to_binary","title":"<code>unary_minus_to_binary(expr, operator_test)</code>","text":"<p>replace unary minus with binary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; o = lambda x: x in ['+', '-', '*', '/', '^']\n&gt;&gt;&gt; unary_minus_to_binary('-x_1+x_2', o)\n'x_2-x_1'\n</code></pre> <pre><code>&gt;&gt;&gt; unary_minus_to_binary('x_1-x_2', o)\n'x_1-x_2'\n</code></pre> <pre><code>&gt;&gt;&gt; unary_minus_to_binary('x_1+(-x_2+x_3)', o)\n'x_1+(x_3-x_2)'\n</code></pre> <pre><code>&gt;&gt;&gt; unary_minus_to_binary('-tan(x_1-exp(x_2))', o)\n'(0-tan(x_1-exp(x_2)))'\n</code></pre> <pre><code>&gt;&gt;&gt; unary_minus_to_binary('-x_2', o)\n'(0-x_2)'\n</code></pre> <pre><code>&gt;&gt;&gt; unary_minus_to_binary('exp(-x_1)*log(x_2)', o)\n'exp((0-x_1))*log(x_2)'\n</code></pre> <pre><code>&gt;&gt;&gt; unary_minus_to_binary('(c_1 + x_2)*(-c_2 + x_3)', o)\n'(c_1+x_2)*(x_3-c_2)'\n</code></pre> <pre><code>&gt;&gt;&gt; unary_minus_to_binary('-(c_1 - x_1)^2', o)\n'(0-(c_1-x_1))^2'\n</code></pre> <pre><code>&gt;&gt;&gt; unary_minus_to_binary('-(c_1 - x_2)*(x_1 + x_2)', o)\n'(0-(c_1-x_2))*(x_1+x_2)'\n</code></pre> Source code in <code>src/equation_tree/util/conversions.py</code> <pre><code>def unary_minus_to_binary(expr, operator_test):\n    \"\"\"\n    replace unary minus with binary\n\n    Examples:\n        &gt;&gt;&gt; o = lambda x: x in ['+', '-', '*', '/', '^']\n        &gt;&gt;&gt; unary_minus_to_binary('-x_1+x_2', o)\n        'x_2-x_1'\n\n        &gt;&gt;&gt; unary_minus_to_binary('x_1-x_2', o)\n        'x_1-x_2'\n\n        &gt;&gt;&gt; unary_minus_to_binary('x_1+(-x_2+x_3)', o)\n        'x_1+(x_3-x_2)'\n\n        &gt;&gt;&gt; unary_minus_to_binary('-tan(x_1-exp(x_2))', o)\n        '(0-tan(x_1-exp(x_2)))'\n\n        &gt;&gt;&gt; unary_minus_to_binary('-x_2', o)\n        '(0-x_2)'\n\n        &gt;&gt;&gt; unary_minus_to_binary('exp(-x_1)*log(x_2)', o)\n        'exp((0-x_1))*log(x_2)'\n\n        &gt;&gt;&gt; unary_minus_to_binary('(c_1 + x_2)*(-c_2 + x_3)', o)\n        '(c_1+x_2)*(x_3-c_2)'\n\n        &gt;&gt;&gt; unary_minus_to_binary('-(c_1 - x_1)^2', o)\n        '(0-(c_1-x_1))^2'\n\n        &gt;&gt;&gt; unary_minus_to_binary('-(c_1 - x_2)*(x_1 + x_2)', o)\n        '(0-(c_1-x_2))*(x_1+x_2)'\n\n    \"\"\"\n    _temp = _find_unary(\"-\", str(expr), operator_test)\n    while \"#\" in _temp:\n        _temp = _move_placeholder(_temp, operator_test)\n    _temp = _find_unary(\"+\", _temp, operator_test)\n    _temp = __remove_character_from_string(_temp, \"#\")\n    _temp = _find_unary(\"-\", _temp, operator_test)\n    while \"#\" in _temp:\n        _temp = _replace_with_zero_minus(_temp, operator_test)\n    return _temp\n</code></pre>"},{"location":"reference/src/equation_tree/util/io/","title":"Io","text":""},{"location":"reference/src/equation_tree/util/priors/","title":"Priors","text":""},{"location":"reference/src/equation_tree/util/priors/#src.equation_tree.util.priors.normalized_dict","title":"<code>normalized_dict(d)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; t_d = {'a': 1, 'b': 3}\n&gt;&gt;&gt; t_d = normalized_dict(t_d)\n&gt;&gt;&gt; t_d\n{'a': 0.25, 'b': 0.75}\n&gt;&gt;&gt; t_d = {'c': 0, 'd': 0}\n&gt;&gt;&gt; t_d = normalized_dict(t_d)\n&gt;&gt;&gt; t_d\n{'c': 0, 'd': 0}\n</code></pre> Source code in <code>src/equation_tree/util/priors.py</code> <pre><code>def normalized_dict(d):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; t_d = {'a': 1, 'b': 3}\n        &gt;&gt;&gt; t_d = normalized_dict(t_d)\n        &gt;&gt;&gt; t_d\n        {'a': 0.25, 'b': 0.75}\n        &gt;&gt;&gt; t_d = {'c': 0, 'd': 0}\n        &gt;&gt;&gt; t_d = normalized_dict(t_d)\n        &gt;&gt;&gt; t_d\n        {'c': 0, 'd': 0}\n    \"\"\"\n    n = sum(d.values())\n    if n == 0:\n        return d\n    else:\n        return {key: value / n for key, value in d.items()}\n</code></pre>"},{"location":"reference/src/equation_tree/util/priors/#src.equation_tree.util.priors.set_priors","title":"<code>set_priors(priors=None, space=None)</code>","text":"<p>Utility function to set priors without setting all probabilities of the space</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; default_priors = set_priors(space=['a', 'b', 'c', 'd'])\n&gt;&gt;&gt; default_priors\n{'a': 0.25, 'b': 0.25, 'c': 0.25, 'd': 0.25}\n</code></pre> <pre><code>&gt;&gt;&gt; custom_priors_full = set_priors({'a' : .3, 'b': .7}, ['a', 'b'])\n&gt;&gt;&gt; custom_priors_full\n{'a': 0.3, 'b': 0.7}\n</code></pre> <pre><code>&gt;&gt;&gt; custom_priors_partial = set_priors({'a' : .5}, ['a', 'b', 'c'])\n&gt;&gt;&gt; custom_priors_partial\n{'a': 0.5, 'b': 0.25, 'c': 0.25}\n</code></pre> Source code in <code>src/equation_tree/util/priors.py</code> <pre><code>def set_priors(priors=None, space=None):\n    \"\"\"\n    Utility function to set priors without setting all probabilities of the space\n\n    Examples:\n        &gt;&gt;&gt; default_priors = set_priors(space=['a', 'b', 'c', 'd'])\n        &gt;&gt;&gt; default_priors\n        {'a': 0.25, 'b': 0.25, 'c': 0.25, 'd': 0.25}\n\n        &gt;&gt;&gt; custom_priors_full = set_priors({'a' : .3, 'b': .7}, ['a', 'b'])\n        &gt;&gt;&gt; custom_priors_full\n        {'a': 0.3, 'b': 0.7}\n\n        &gt;&gt;&gt; custom_priors_partial = set_priors({'a' : .5}, ['a', 'b', 'c'])\n        &gt;&gt;&gt; custom_priors_partial\n        {'a': 0.5, 'b': 0.25, 'c': 0.25}\n    \"\"\"\n    if space is None:\n        space = []\n    if priors is None:\n        priors = {}\n\n    n = len(space)\n    default_prior = 1 / n\n\n    # Set all to default to begin with\n    _priors = {el: default_prior for el in space}\n\n    # If the user provides priors\n    if priors:\n        if not set(priors.keys()).issubset(set(space)):\n            raise Exception(f\"Priors {priors} are not subset of space {space}\")\n        total_custom_prior = sum(math.floor(p * 100) / 100 for p in (priors.values()))\n        if total_custom_prior &gt; 1:\n            raise ValueError(f\"Sum of custom priors {priors} is greater than 1\")\n\n        # Update the priors dict with custom values\n        for key, value in priors.items():\n            _priors[key] = value\n\n        # Adjust the other priors\n        remaining_probability = 1 - total_custom_prior\n        num_unset_possibilities = n - len(priors)\n        for key in _priors:\n            if key not in priors:\n                _priors[key] = remaining_probability / num_unset_possibilities\n    return _normalize(_priors)\n</code></pre>"},{"location":"reference/src/equation_tree/util/type_check/","title":"Type check","text":""},{"location":"reference/src/equation_tree/util/type_check/#src.equation_tree.util.type_check.check_functions","title":"<code>check_functions(expression, function_test)</code>","text":"Example <p>from sympy import sympify expr = sympify('sin(x)') check_functions(expr, lambda x: x in ['sin']) True</p> <p>expr = sympify('x + y') check_functions(expr, lambda x: x in ['sin']) True</p> <p>expr = sympify('sin(x) + cos(y)') check_functions(expr, lambda x: x in ['sin', 'cos']) True</p> <p>check_functions(expr, lambda x: x in ['sin']) False</p> Source code in <code>src/equation_tree/util/type_check.py</code> <pre><code>def check_functions(expression, function_test):\n    \"\"\"\n    Example:\n        &gt;&gt;&gt; from sympy import sympify\n        &gt;&gt;&gt; expr = sympify('sin(x)')\n        &gt;&gt;&gt; check_functions(expr, lambda x: x in ['sin'])\n        True\n\n        &gt;&gt;&gt; expr = sympify('x + y')\n        &gt;&gt;&gt; check_functions(expr, lambda x: x in ['sin'])\n        True\n\n        &gt;&gt;&gt; expr = sympify('sin(x) + cos(y)')\n        &gt;&gt;&gt; check_functions(expr, lambda x: x in ['sin', 'cos'])\n        True\n\n        &gt;&gt;&gt; check_functions(expr, lambda x: x in ['sin'])\n        False\n\n    \"\"\"\n\n    def apply_test(node):\n        if isinstance(node, Function):\n            return function_test(str(node.func).lower()) or str(node.func) == \"re\"\n        elif isinstance(node, (Add, Mul, Pow)):\n            return all(apply_test(arg) or str(node.func) == \"re\" for arg in node.args)\n        return True\n\n    return apply_test(expression)\n</code></pre>"},{"location":"reference/src/equation_tree/util/type_check/#src.equation_tree.util.type_check.is_constant_formatted","title":"<code>is_constant_formatted(s)</code>","text":"<p>Tests weather the input is in standard format for a constant</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_constant_formatted('c_4')\nTrue\n&gt;&gt;&gt; is_constant_formatted('c_42')\nTrue\n&gt;&gt;&gt; is_constant_formatted('c_a')\nFalse\n&gt;&gt;&gt; is_constant_formatted('abc')\nFalse\n&gt;&gt;&gt; is_constant_formatted('x_3')\nFalse\n</code></pre> Source code in <code>src/equation_tree/util/type_check.py</code> <pre><code>def is_constant_formatted(s: str):\n    \"\"\"\n    Tests weather the input is in standard format for a constant\n\n    Examples:\n        &gt;&gt;&gt; is_constant_formatted('c_4')\n        True\n        &gt;&gt;&gt; is_constant_formatted('c_42')\n        True\n        &gt;&gt;&gt; is_constant_formatted('c_a')\n        False\n        &gt;&gt;&gt; is_constant_formatted('abc')\n        False\n        &gt;&gt;&gt; is_constant_formatted('x_3')\n        False\n    \"\"\"\n    pattern = r\"^c_\\d+$\"\n    return re.match(pattern, s) is not None\n</code></pre>"},{"location":"reference/src/equation_tree/util/type_check/#src.equation_tree.util.type_check.is_numeric","title":"<code>is_numeric(s)</code>","text":"<p>Tests weather the input is a number</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_numeric('0')\nTrue\n&gt;&gt;&gt; is_numeric('10')\nTrue\n&gt;&gt;&gt; is_numeric('hallo')\nFalse\n&gt;&gt;&gt; is_numeric('.1')\nTrue\n&gt;&gt;&gt; is_numeric('+.1')\nFalse\n</code></pre> Source code in <code>src/equation_tree/util/type_check.py</code> <pre><code>def is_numeric(s):\n    \"\"\"\n    Tests weather the input is a number\n\n    Examples:\n        &gt;&gt;&gt; is_numeric('0')\n        True\n        &gt;&gt;&gt; is_numeric('10')\n        True\n        &gt;&gt;&gt; is_numeric('hallo')\n        False\n        &gt;&gt;&gt; is_numeric('.1')\n        True\n        &gt;&gt;&gt; is_numeric('+.1')\n        False\n\n    \"\"\"\n    if isinstance(s, str) and (not s[0].isnumeric() and s[0] != \".\"):\n        return False\n    try:\n        float(s)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"reference/src/equation_tree/util/type_check/#src.equation_tree.util.type_check.is_variable_formatted","title":"<code>is_variable_formatted(s)</code>","text":"<p>Tests weather the input is in standard format for a variable</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_variable_formatted('x_1')\nTrue\n&gt;&gt;&gt; is_variable_formatted('x_42')\nTrue\n&gt;&gt;&gt; is_variable_formatted('x_a')\nFalse\n&gt;&gt;&gt; is_variable_formatted('abc')\nFalse\n&gt;&gt;&gt; is_variable_formatted('c_3')\nFalse\n</code></pre> Source code in <code>src/equation_tree/util/type_check.py</code> <pre><code>def is_variable_formatted(s: str):\n    \"\"\"\n    Tests weather the input is in standard format for a variable\n\n    Examples:\n        &gt;&gt;&gt; is_variable_formatted('x_1')\n        True\n        &gt;&gt;&gt; is_variable_formatted('x_42')\n        True\n        &gt;&gt;&gt; is_variable_formatted('x_a')\n        False\n        &gt;&gt;&gt; is_variable_formatted('abc')\n        False\n        &gt;&gt;&gt; is_variable_formatted('c_3')\n        False\n    \"\"\"\n    pattern = r\"^x_\\d+$\"\n    return re.match(pattern, s) is not None\n</code></pre>"},{"location":"reference/src/equation_tree/util/type_check/#src.equation_tree.util.type_check.parse_string_list_int","title":"<code>parse_string_list_int(lst)</code>","text":"Example <p>a = '[1, 2, 3, 4]' parse_string_list_int(a) [1, 2, 3, 4] b = '[10, 2, 3]' parse_string_list_int(b) [10, 2, 3]</p> Source code in <code>src/equation_tree/util/type_check.py</code> <pre><code>def parse_string_list_int(lst):\n    \"\"\"\n    Example:\n        &gt;&gt;&gt; a = '[1, 2, 3, 4]'\n        &gt;&gt;&gt; parse_string_list_int(a)\n        [1, 2, 3, 4]\n        &gt;&gt;&gt; b = '[10, 2, 3]'\n        &gt;&gt;&gt; parse_string_list_int(b)\n        [10, 2, 3]\n    \"\"\"\n    res = []\n    i = 0\n    while i &lt; len(lst) - 1:\n        start = i\n        end = i\n        while is_numeric(lst[i]):\n            end += 1\n            i += 1\n        if start != end:\n            i = end\n            res.append(int(lst[start:end]))\n        i += 1\n    return res\n</code></pre>"}]}